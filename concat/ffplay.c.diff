diff --git a/ffplay.c b/ffplay.c
index 5f88a46..b49b978 100644
--- a/ffplay.c
+++ b/ffplay.c
@@ -30,6 +30,8 @@
 #include "libavcodec/colorspace.h"
 #include "libavcodec/opt.h"
 
+#include "libavformat/playlist.h"
+
 #include "cmdutils.h"
 
 #include <SDL.h>
@@ -1336,28 +1338,65 @@ static int video_thread(void *arg)
     VideoState *is = arg;
     AVPacket pkt1, *pkt = &pkt1;
     int len1, got_picture;
-    AVFrame *frame= avcodec_alloc_frame();
+    AVFrame *frame;
     double pts;
-
+    PlaylistContext *pl_ctx;
+    int st_idx = 0;
+    char tryswitchalready = 0;
+    frame = avcodec_alloc_frame();
+    pl_ctx = ff_playlist_get_context(is->ic);
     for(;;) {
         while (is->paused && !is->videoq.abort_request) {
             SDL_Delay(10);
         }
+
         if (packet_queue_get(&is->videoq, pkt, 1) < 0)
             break;
 
+        tryagain:
+
         if(pkt->data == flush_pkt.data){
             avcodec_flush_buffers(is->video_st->codec);
             continue;
         }
-
         /* NOTE: ipts is the PTS of the _first_ picture beginning in
            this packet, if any */
+
         is->video_st->codec->reordered_opaque= pkt->pts;
+
         len1 = avcodec_decode_video2(is->video_st->codec,
                                     frame, &got_picture,
                                     pkt);
 
+        if (pl_ctx && pkt && !tryswitchalready) {
+            tryswitchalready = 1;
+//            AVStream *propst = ff_playlist_get_stream(pl_ctx, st_idx+1, pkt->stream_index);
+//            if (propst && propst->codec && propst->codec->codec_type == CODEC_TYPE_VIDEO) {
+//                is->video_st = propst;
+//                ++st_idx;
+//            }
+            if (pkt->stream && pkt->stream->codec && pkt->stream->codec->codec_type == CODEC_TYPE_VIDEO) {
+                if (!pkt->stream->codec->codec) {
+                    AVCodec *codec = avcodec_find_decoder(pkt->stream->codec->codec_id);
+                    if (!codec) {
+                        fprintf(stderr, "output_packet: Decoder (codec id %d) not found for input stream #%d\n",
+                                pkt->stream->codec->codec_id, pkt->stream->index);
+                        return AVERROR(EINVAL);
+                    }
+                    if (avcodec_open(pkt->stream->codec, codec) < 0) {
+                        fprintf(stderr, "output_packet: Error while opening decoder for input stream #%d\n",
+                                pkt->stream->index);
+                        return AVERROR(EINVAL);
+                     }
+                }
+                if (is->video_st != pkt->stream) {
+                    is->video_st = pkt->stream;
+                    goto tryagain;
+                }
+            }
+        }
+        tryswitchalready = 0;
+
         if(   (decoder_reorder_pts || pkt->dts == AV_NOPTS_VALUE)
            && frame->reordered_opaque != AV_NOPTS_VALUE)
             pts= frame->reordered_opaque;
@@ -1366,9 +1405,6 @@ static int video_thread(void *arg)
         else
             pts= 0;
         pts *= av_q2d(is->video_st->time_base);
-
-//            if (len1 < 0)
-//                break;
         if (got_picture) {
             if (output_picture2(is, frame, pts) < 0)
                 goto the_end;
@@ -1561,50 +1597,76 @@ static int audio_decode_frame(VideoState *is, double *pts_ptr)
 {
     AVPacket *pkt_temp = &is->audio_pkt_temp;
     AVPacket *pkt = &is->audio_pkt;
-    AVCodecContext *dec= is->audio_st->codec;
     int n, len1, data_size;
     double pts;
-
+    int st_idx = 0;
+    PlaylistContext *pl_ctx;
+    char tryswitchalready = 0;
+    pl_ctx = ff_playlist_get_context(is->ic);
     for(;;) {
-        /* NOTE: the audio packet can contain several frames */
         while (pkt_temp->size > 0) {
+            tryagain:
             data_size = sizeof(is->audio_buf1);
-            len1 = avcodec_decode_audio3(dec,
+            len1 = avcodec_decode_audio3(is->audio_st->codec,
                                         (int16_t *)is->audio_buf1, &data_size,
                                         pkt_temp);
             if (len1 < 0) {
                 /* if error, we skip the frame */
                 pkt_temp->size = 0;
+                if (pl_ctx && pkt) {
+                    AVStream *propst = 0;//ff_playlist_get_stream(pl_ctx, st_idx+1, pkt->stream_index);
+                    if (propst && propst->codec && propst->codec->codec_type == CODEC_TYPE_AUDIO) {
+                        if (!propst->codec->codec) {
+                            AVCodec *codec = avcodec_find_decoder(propst->codec->codec_id);
+                            if (!codec) {
+                                av_log(propst->codec, AV_LOG_ERROR, "Decoder (codec id %d) not found for input stream #%d\n",
+                                       propst->codec->codec_id, propst->index);
+                                return AVERROR(EINVAL);
+                            }
+                            if (avcodec_open(propst->codec, codec) < 0) {
+                                av_log(propst->codec, AV_LOG_ERROR, "Error while opening decoder for input stream #%d\n",
+                                       propst->index);
+                                return AVERROR(EINVAL);
+                            }
+                        }
+                        is->audio_st = propst;
+                        ++st_idx;
+                    }
+                }
+                if (pl_ctx && !tryswitchalready) {
+                    tryswitchalready = 1;
+                    goto tryagain;
+                }
+                tryswitchalready = 0;
                 break;
             }
+            tryswitchalready = 0;
 
             pkt_temp->data += len1;
             pkt_temp->size -= len1;
             if (data_size <= 0)
                 continue;
-
-            if (dec->sample_fmt != is->audio_src_fmt) {
+            if (is->audio_st->codec->sample_fmt != is->audio_src_fmt) {
                 if (is->reformat_ctx)
                     av_audio_convert_free(is->reformat_ctx);
                 is->reformat_ctx= av_audio_convert_alloc(SAMPLE_FMT_S16, 1,
-                                                         dec->sample_fmt, 1, NULL, 0);
+                                                         is->audio_st->codec->sample_fmt, 1, NULL, 0);
                 if (!is->reformat_ctx) {
                     fprintf(stderr, "Cannot convert %s sample format to %s sample format\n",
-                        avcodec_get_sample_fmt_name(dec->sample_fmt),
+                        avcodec_get_sample_fmt_name(is->audio_st->codec->sample_fmt),
                         avcodec_get_sample_fmt_name(SAMPLE_FMT_S16));
                         break;
                 }
-                is->audio_src_fmt= dec->sample_fmt;
+                is->audio_src_fmt= is->audio_st->codec->sample_fmt;
             }
-
             if (is->reformat_ctx) {
                 const void *ibuf[6]= {is->audio_buf1};
                 void *obuf[6]= {is->audio_buf2};
-                int istride[6]= {av_get_bits_per_sample_format(dec->sample_fmt)/8};
+                int istride[6]= {av_get_bits_per_sample_format(is->audio_st->codec->sample_fmt)/8};
                 int ostride[6]= {2};
                 int len= data_size/istride[0];
                 if (av_audio_convert(is->reformat_ctx, obuf, ostride, ibuf, istride, len)<0) {
-                    printf("av_audio_convert() failed\n");
+                    fprintf(stderr, "av_audio_convert() failed\n");
                     break;
                 }
                 is->audio_buf= is->audio_buf2;
@@ -1618,9 +1680,9 @@ static int audio_decode_frame(VideoState *is, double *pts_ptr)
             /* if no pts, then compute it */
             pts = is->audio_clock;
             *pts_ptr = pts;
-            n = 2 * dec->channels;
+            n = 2 * is->audio_st->codec->channels;
             is->audio_clock += (double)data_size /
-                (double)(n * dec->sample_rate);
+                (double)(n * is->audio_st->codec->sample_rate);
 #if defined(DEBUG_SYNC)
             {
                 static double last_clock;
@@ -1632,7 +1694,6 @@ static int audio_decode_frame(VideoState *is, double *pts_ptr)
 #endif
             return data_size;
         }
-
         /* free the current packet */
         if (pkt->data)
             av_free_packet(pkt);
@@ -1645,7 +1706,7 @@ static int audio_decode_frame(VideoState *is, double *pts_ptr)
         if (packet_queue_get(&is->audioq, pkt, 1) < 0)
             return -1;
         if(pkt->data == flush_pkt.data){
-            avcodec_flush_buffers(dec);
+            avcodec_flush_buffers(is->audio_st->codec);
             continue;
         }
 
