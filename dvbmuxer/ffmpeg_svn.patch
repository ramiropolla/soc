Index: libavformat/mpegpes.h
===================================================================
--- libavformat/mpegpes.h	(revision 0)
+++ libavformat/mpegpes.h	(revision 0)
@@ -0,0 +1,139 @@
+/*
+ * Copyright (c) 2000-2002 Fabrice Bellard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file mpegpes.h
+ * MPEG PES packetizer API header
+ */
+
+#ifndef FFMPEG_MPEGPES_H
+#define FFMPEG_MPEGPES_H
+
+#include "avformat.h"
+#include "libavutil/fifo.h"
+
+#define PES_FMT_MPEG2 0x01
+#define PES_FMT_VCD   0x02
+// formats below are all mpeg-2
+#define PES_FMT_SVCD  0x05
+#define PES_FMT_DVD   0x09
+#define PES_FMT_TS    0x11
+
+/**
+ * PES packet description
+ */
+typedef struct PacketDesc {
+    int64_t pts;
+    int64_t dts;
+    int size;
+    int unwritten_size;
+    int flags;
+    struct PacketDesc *next;
+} PacketDesc;
+
+/**
+ * PES stream structure
+ */
+typedef struct {
+    AVFifoBuffer fifo;
+    uint8_t id;
+    int max_buffer_size; /**< in bytes */
+    int buffer_index;
+    PacketDesc *predecode_packet;
+    PacketDesc *premux_packet;
+    PacketDesc **next_packet;
+    int packet_number;
+    uint8_t lpcm_header[3];
+    int lpcm_align;
+    int bytes_to_iframe;
+    int align_iframe;
+    int64_t vobu_start_pts;
+    int format; ///< mux format (ts, svcd ...)
+} StreamInfo;
+
+#define PRIVATE_STREAM_1   0x1bd
+#define PADDING_STREAM     0x1be
+
+/**
+ * Initialization of PES muxer.
+ * @param[in] ctx AVFormatContext
+ * @return        Negative value on error, zero on success
+ */
+int ff_pes_muxer_init(AVFormatContext *ctx);
+
+/**
+ * Finalization of PES muxer.
+ * @param [in] ctx AVFormatContext
+ */
+void ff_pes_muxer_end(AVFormatContext *ctx);
+
+/**
+ * Write packet into PES fifo.
+ * @param [in] ctx           AVFormatContext
+ * @param [in] pkt           Packet to write
+ * @param [in] packet_number Current muxer packet number
+ */
+void ff_pes_write_packet(AVFormatContext *ctx, AVPacket *pkt, int packet_number);
+
+/**
+ * Output PES packet to the output file.
+ * @param[in]  ctx          AVFormatContext
+ * @param[in]  packet_size  PES stream packet size
+ * @param[in]  flush        Wether flushing remaining data is needed
+ * @param[in]  scr          Last clock reference (SCR for PS, PCR for TS)
+ * @param[out] scr          Updated clock reference, bumped if needed
+ * @param[out] best_i       Index of the stream muxed
+ * @param[in]  flush_packet Function to call to actually write packet to file
+ * @return                  Negative on error, zero if no packet output,
+ *                          else Byte size of flushed data
+ */
+int ff_pes_output_packet(AVFormatContext *ctx, int packet_size,
+                         int64_t *scr, int *best_i, int flush,
+                         int (*flush_packet)(AVFormatContext *, int, int64_t,
+                                             int64_t, int64_t, int));
+
+/**
+ * Write PES data from PES Stream into supplied buffer.
+ * @param [in]  ctx               AVFormatContext
+ * @param [in]  stream_index      Stream index to write from
+ * @param [in]  buf               Buffer to write to
+ * @param [in]  pts               Packet pts
+ * @param [in]  dts               Packet dts
+ * @param [in]  trailer_size      Packet trailer size
+ * @param [in]  packet_size       Total packet size
+ * @param [in]  pad_packet_bytes  Packet padding size
+ * @param [out] payload_size      Packet payload size
+ * @param [out] stuffing_size     Packet stuffing size
+ * @return                        Bytes written to buffer
+ */
+int ff_pes_write_buf(AVFormatContext *ctx, int stream_index, uint8_t *buf,
+          int64_t *pts, int64_t *dts,
+          int trailer_size, int *packet_size, int *pad_packet_bytes,
+          int *payload_size, int *stuffing_size);
+
+/**
+ * Remove decoded packets of each stream.
+ * @param[in] ctx  the AVFormatContext
+ * @param[in] scr  Clock Reference (SCR for PS, PCR for TS)
+ * @return         Negative value on error, 0 on success
+ */
+int ff_pes_remove_decoded_packets(AVFormatContext *ctx, int64_t scr);
+
+#endif /* FFMPEG_MPEGPES_H */
Index: libavformat/mpegpesenc.c
===================================================================
--- libavformat/mpegpesenc.c	(revision 0)
+++ libavformat/mpegpesenc.c	(revision 0)
@@ -0,0 +1,450 @@
+/*
+ * MPEG PES muxer
+ * Copyright (c) 2000-2002 Fabrice Bellard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "mpegpes.h"
+#include "mpeg.h"
+#include "libavcodec/bytestream.h"
+
+int ff_pes_muxer_init(AVFormatContext *ctx)
+{
+    int i;
+
+    for(i=0;i<ctx->nb_streams;i++) {
+        AVStream *st = ctx->streams[i];
+        StreamInfo *stream = st->priv_data;
+        av_set_pts_info(st, 64, 1, 90000);
+
+        switch(st->codec->codec_type) {
+        case CODEC_TYPE_AUDIO:
+            /* This value HAS to be used for VCD (see VCD standard, p. IV-7).
+               Right now it is also used for everything else.*/
+            stream->max_buffer_size = 4 * 1024;
+            break;
+        case CODEC_TYPE_VIDEO:
+            if (st->codec->rc_buffer_size)
+                stream->max_buffer_size = 6*1024 + st->codec->rc_buffer_size/8;
+            else
+                stream->max_buffer_size = 230*1024; //FIXME this is probably too small as default
+#if 0
+                /* see VCD standard, p. IV-7*/
+                stream->max_buffer_size = 46 * 1024;
+            else
+                /* This value HAS to be used for SVCD (see SVCD standard, p. 26 V.2.3.2).
+                   Right now it is also used for everything else.*/
+                stream->max_buffer_size = 230 * 1024;
+#endif
+            break;
+        case CODEC_TYPE_SUBTITLE:
+            stream->max_buffer_size = 16 * 1024;
+            break;
+        default:
+            return -1;
+        }
+        av_fifo_init(&stream->fifo, 16);
+    }
+    return 0;
+}
+
+static inline void put_timestamp(uint8_t** p, int id, int64_t timestamp)
+{
+    bytestream_put_byte(p,
+        (id << 4) |
+        (((timestamp >> 30) & 0x07) << 1) |
+        1);
+    bytestream_put_be16(p, (uint16_t)((((timestamp >> 15) & 0x7fff) << 1) | 1));
+    bytestream_put_be16(p, (uint16_t)((((timestamp) & 0x7fff) << 1) | 1));
+}
+
+static int get_nb_frames(AVFormatContext *ctx, StreamInfo *stream, int len){
+    int nb_frames=0;
+    PacketDesc *pkt_desc= stream->premux_packet;
+
+    while(len>0){
+        if(pkt_desc->size == pkt_desc->unwritten_size)
+            nb_frames++;
+        len -= pkt_desc->unwritten_size;
+        pkt_desc= pkt_desc->next;
+    }
+
+    return nb_frames;
+}
+
+int ff_pes_write_buf(AVFormatContext *ctx, int stream_index, uint8_t *buf,
+                     int64_t *pts, int64_t *dts,
+                     int trailer_size, int *packet_size, int *pad_packet_bytes,
+                     int *payload_size, int *stuffing_size)
+{
+    StreamInfo *stream = ctx->streams[stream_index]->priv_data;
+    int startcode, i, header_len;
+    int pes_flags = 0;
+    uint8_t *p = buf;
+    int nb_frames;
+
+    /* packet header size */
+    *packet_size -= 6;
+
+    /* packet header */
+    if (stream->format & PES_FMT_MPEG2) {
+        header_len = 3;
+        if (stream->packet_number==0)
+            header_len += 3; /* PES extension */
+        header_len += 1; /* obligatory stuffing byte */
+    } else {
+        header_len = 0;
+    }
+
+    if (*pts != AV_NOPTS_VALUE) {
+        if (*dts != *pts)
+            header_len += 5 + 5;
+        else
+            header_len += 5;
+    } else {
+        if (!(stream->format & PES_FMT_MPEG2))
+            header_len++;
+    }
+
+    *payload_size = *packet_size - header_len;
+    if (stream->id < 0xc0) {
+        startcode = PRIVATE_STREAM_1;
+        *payload_size -= 1;
+        if (stream->id >= 0x40) {
+            *payload_size -= 3;
+            if (stream->id >= 0xa0)
+                *payload_size -= 3;
+        }
+    } else {
+        startcode = 0x100 + stream->id;
+    }
+
+    *stuffing_size = *payload_size - av_fifo_size(&stream->fifo);
+
+    // first byte does not fit -> reset pts/dts + stuffing
+    if(*payload_size <= trailer_size && *pts != AV_NOPTS_VALUE){
+        int timestamp_len=0;
+        if(*dts != *pts)
+            timestamp_len += 5;
+        if(*pts != AV_NOPTS_VALUE)
+            timestamp_len += stream->format & PES_FMT_MPEG2 ? 5 : 4;
+        *pts=*dts= AV_NOPTS_VALUE;
+        header_len -= timestamp_len;
+        if (stream->format == PES_FMT_DVD && stream->align_iframe) {
+            *pad_packet_bytes += timestamp_len;
+            *packet_size -= timestamp_len;
+        } else {
+            *payload_size += timestamp_len;
+        }
+        *stuffing_size += timestamp_len;
+        if(*payload_size > trailer_size)
+            *stuffing_size += *payload_size - trailer_size;
+    }
+
+    if (*pad_packet_bytes > 0 && *pad_packet_bytes <= 7) { // can't use padding, so use stuffing
+        *packet_size += *pad_packet_bytes;
+        *payload_size += *pad_packet_bytes; // undo the previous adjustment
+        if (*stuffing_size < 0) {
+            *stuffing_size = *pad_packet_bytes;
+        } else {
+            *stuffing_size += *pad_packet_bytes;
+        }
+        *pad_packet_bytes = 0;
+    }
+
+    if (*stuffing_size < 0)
+        *stuffing_size = 0;
+    if (*stuffing_size > 16) {    /*<=16 for MPEG-1, <=32 for MPEG-2*/
+        *pad_packet_bytes += *stuffing_size;
+        *packet_size -= *stuffing_size;
+        *payload_size -= *stuffing_size;
+        *stuffing_size = 0;
+    }
+
+    nb_frames= get_nb_frames(ctx, stream, *payload_size - *stuffing_size);
+
+    bytestream_put_be32(&p, startcode);
+
+    bytestream_put_be16(&p, *packet_size);
+
+    if (!(stream->format & PES_FMT_MPEG2))
+        for(i=0;i<*stuffing_size;i++)
+            bytestream_put_byte(&p, 0xff);
+
+    if (stream->format & PES_FMT_MPEG2) {
+        bytestream_put_byte(&p, 0x80); /* mpeg2 id */
+
+        pes_flags=0;
+
+        if (*pts != AV_NOPTS_VALUE) {
+            pes_flags |= 0x80;
+            if (*dts != *pts)
+                pes_flags |= 0x40;
+        }
+
+        /* Both the MPEG-2 and the SVCD standards demand that the
+           P-STD_buffer_size field be included in the first packet of
+           every stream. (see SVCD standard p. 26 V.2.3.1 and V.2.3.2
+           and MPEG-2 standard 2.7.7) */
+        if (stream->packet_number == 0)
+            pes_flags |= 0x01;
+
+        bytestream_put_byte(&p, pes_flags); /* flags */
+        bytestream_put_byte(&p, header_len - 3 + *stuffing_size);
+
+        if (pes_flags & 0x80)  /*write pts*/
+            put_timestamp(&p, (pes_flags & 0x40) ? 0x03 : 0x02, *pts);
+        if (pes_flags & 0x40)  /*write dts*/
+            put_timestamp(&p, 0x01, *dts);
+
+        if (pes_flags & 0x01) {  /*write pes extension*/
+            bytestream_put_byte(&p, 0x10); /* flags */
+
+            /* P-STD buffer info */
+            if (stream->id == AUDIO_ID)
+                bytestream_put_be16(&p, 0x4000 | stream->max_buffer_size/128);
+            else
+                bytestream_put_be16(&p, 0x6000 | stream->max_buffer_size/1024);
+        }
+
+    } else {
+        if (*pts != AV_NOPTS_VALUE) {
+            if (*dts != *pts) {
+                put_timestamp(&p, 0x03, *pts);
+                put_timestamp(&p, 0x01, *dts);
+            } else {
+                put_timestamp(&p, 0x02, *pts);
+            }
+        } else {
+            bytestream_put_byte(&p, 0x0f);
+        }
+    }
+
+    if (stream->format & PES_FMT_MPEG2) {
+        /* special stuffing byte that is always written
+           to prevent accidental generation of start codes. */
+        bytestream_put_byte(&p, 0xff);
+
+        for(i=0;i<*stuffing_size;i++)
+            bytestream_put_byte(&p, 0xff);
+    }
+
+    if (startcode == PRIVATE_STREAM_1) {
+        bytestream_put_byte(&p, stream->id);
+        if (stream->id >= 0xa0) {
+            /* LPCM (XXX: check nb_frames) */
+            bytestream_put_byte(&p, 7);
+            bytestream_put_be16(&p, 4); /* skip 3 header bytes */
+            bytestream_put_byte(&p, stream->lpcm_header[0]);
+            bytestream_put_byte(&p, stream->lpcm_header[1]);
+            bytestream_put_byte(&p, stream->lpcm_header[2]);
+        } else if (stream->id >= 0x40) {
+            /* AC3 */
+            bytestream_put_byte(&p, nb_frames);
+            bytestream_put_be16(&p, trailer_size+1);
+        }
+    }
+
+    /* output data */
+    assert(*payload_size - *stuffing_size <= av_fifo_size(&stream->fifo));
+    if(av_fifo_read(&stream->fifo, p, *payload_size - *stuffing_size) < 0)
+        return -1;
+    return p - buf + *payload_size - *stuffing_size;
+}
+
+int ff_pes_remove_decoded_packets(AVFormatContext *ctx, int64_t scr)
+{
+    int i;
+
+    for(i=0; i<ctx->nb_streams; i++){
+        AVStream *st = ctx->streams[i];
+        StreamInfo *stream = st->priv_data;
+        PacketDesc *pkt_desc;
+
+        while((pkt_desc= stream->predecode_packet)
+              && scr > pkt_desc->dts){ //FIXME > vs >=
+            if(stream->buffer_index < pkt_desc->size ||
+               stream->predecode_packet == stream->premux_packet){
+                av_log(ctx, AV_LOG_ERROR,
+                       "buffer underflow i=%d bufi=%d size=%d\n",
+                       i, stream->buffer_index, pkt_desc->size);
+                break;
+            }
+            stream->buffer_index -= pkt_desc->size;
+
+            stream->predecode_packet= pkt_desc->next;
+            av_freep(&pkt_desc);
+        }
+    }
+
+    return 0;
+}
+
+void ff_pes_write_packet(AVFormatContext *ctx, AVPacket *pkt, int packet_number)
+{
+    int stream_index= pkt->stream_index;
+    int size= pkt->size;
+    uint8_t *buf= pkt->data;
+    AVStream *st= ctx->streams[stream_index];
+    StreamInfo *stream= st->priv_data;
+    int64_t pts, dts;
+    PacketDesc *pkt_desc;
+    const int preload= av_rescale(ctx->preload, 90000, AV_TIME_BASE);
+    const int is_iframe = st->codec->codec_type == CODEC_TYPE_VIDEO && (pkt->flags & PKT_FLAG_KEY);
+
+    pts= pkt->pts;
+    dts= pkt->dts;
+
+    if(pts != AV_NOPTS_VALUE) pts += preload;
+    if(dts != AV_NOPTS_VALUE) dts += preload;
+
+//av_log(ctx, AV_LOG_DEBUG, "dts:%f pts:%f flags:%d stream:%d nopts:%d\n", dts/90000.0, pts/90000.0, pkt->flags, pkt->stream_index, pts != AV_NOPTS_VALUE);
+    if (!stream->premux_packet)
+        stream->next_packet = &stream->premux_packet;
+    *stream->next_packet=
+    pkt_desc= av_mallocz(sizeof(PacketDesc));
+    pkt_desc->pts= pts;
+    pkt_desc->dts= dts;
+    pkt_desc->unwritten_size=
+    pkt_desc->size= size;
+    if(!stream->predecode_packet)
+        stream->predecode_packet= pkt_desc;
+    stream->next_packet= &pkt_desc->next;
+
+    av_fifo_realloc(&stream->fifo, av_fifo_size(&stream->fifo) + size);
+
+    if (stream->format == PES_FMT_DVD){
+        if (is_iframe && (packet_number == 0 || (pts - stream->vobu_start_pts >= 36000))) { // min VOBU length 0.4 seconds (mpucoder)
+            stream->bytes_to_iframe = av_fifo_size(&stream->fifo);
+            stream->align_iframe = 1;
+            stream->vobu_start_pts = pts;
+        }
+    }
+
+    av_fifo_generic_write(&stream->fifo, buf, size, NULL);
+}
+
+int ff_pes_output_packet(AVFormatContext *ctx, int packet_size, int64_t *scr,
+                         int *best_i, int flush, int (*flush_packet)())
+{
+    AVStream *st;
+    StreamInfo *stream;
+    int i, avail_space=0, trailer_size;
+    int best_score= INT_MIN;
+    int ignore_constraints=0;
+    PacketDesc *timestamp_packet;
+    const int64_t max_delay= av_rescale(ctx->max_delay, 90000, AV_TIME_BASE);
+
+retry:
+    for(i=0; i<ctx->nb_streams; i++){
+        AVStream *st= ctx->streams[i];
+        StreamInfo *stream= st->priv_data;
+        const int avail_data= av_fifo_size(&stream->fifo);
+        const int space= stream->max_buffer_size - stream->buffer_index;
+        int rel_space= 1024*space / stream->max_buffer_size;
+        PacketDesc *next_pkt= stream->premux_packet;
+
+        /* for subtitle, a single PES packet must be generated,
+           so we flush after every single subtitle packet */
+        if(packet_size > avail_data && !flush
+           && st->codec->codec_type != CODEC_TYPE_SUBTITLE)
+            return 0;
+        if(avail_data==0)
+            continue;
+        assert(avail_data>0);
+
+        if(space < packet_size && !ignore_constraints)
+            continue;
+
+        if(next_pkt && next_pkt->dts - *scr > max_delay)
+            continue;
+
+        if(rel_space > best_score){
+            best_score= rel_space;
+            *best_i = i;
+            avail_space= space;
+        }
+    }
+
+    if(*best_i < 0){
+        int64_t best_dts= INT64_MAX;
+
+        for(i=0; i<ctx->nb_streams; i++){
+            AVStream *st = ctx->streams[i];
+            StreamInfo *stream = st->priv_data;
+            PacketDesc *pkt_desc= stream->predecode_packet;
+            if(pkt_desc && pkt_desc->dts < best_dts)
+                best_dts= pkt_desc->dts;
+        }
+
+#if 0
+        av_log(ctx, AV_LOG_DEBUG, "bumping scr, scr:%f, dts:%f\n",
+               scr/90000.0, best_dts/90000.0);
+#endif
+        if(best_dts == INT64_MAX)
+            return 0;
+
+        if(*scr >= best_dts+1 && !ignore_constraints){
+            av_log(ctx, AV_LOG_ERROR, "packet too large, ignoring buffer limits to mux it\n");
+            ignore_constraints= 1;
+        }
+        *scr= FFMAX(best_dts+1, *scr);
+        if(ff_pes_remove_decoded_packets(ctx, *scr) < 0)
+            return -1;
+        goto retry;
+    }
+
+    assert(*best_i >= 0);
+
+    st = ctx->streams[*best_i];
+    stream = st->priv_data;
+
+    assert(av_fifo_size(&stream->fifo) > 0);
+
+    assert(avail_space >= packet_size || ignore_constraints);
+
+    timestamp_packet= stream->premux_packet;
+    if(timestamp_packet->unwritten_size == timestamp_packet->size){
+        trailer_size= 0;
+    }else{
+        trailer_size= timestamp_packet->unwritten_size;
+        timestamp_packet= timestamp_packet->next;
+    }
+
+    if(timestamp_packet){
+//av_log(ctx, AV_LOG_DEBUG, "dts:%f pts:%f pcr:%f stream:%d\n", timestamp_packet->dts/90000.0, timestamp_packet->pts/90000.0, pcr/90000.0, best_i);
+        return flush_packet(ctx, *best_i, timestamp_packet->pts, timestamp_packet->dts, *scr, trailer_size);
+    }else{
+        assert(av_fifo_size(&stream->fifo) == trailer_size);
+        return flush_packet(ctx, *best_i, AV_NOPTS_VALUE, AV_NOPTS_VALUE, *scr, trailer_size);
+    }
+}
+
+
+void ff_pes_muxer_end(AVFormatContext *ctx)
+{
+    StreamInfo *stream;
+    int i;
+
+    for(i=0;i<ctx->nb_streams;i++) {
+        stream = ctx->streams[i]->priv_data;
+
+        assert(av_fifo_size(&stream->fifo) == 0);
+        av_fifo_free(&stream->fifo);
+    }
+}
Index: libavformat/Makefile
===================================================================
--- libavformat/Makefile	(revision 13661)
+++ libavformat/Makefile	(working copy)
@@ -102,7 +102,7 @@
 OBJS-$(CONFIG_MPEGPS_DEMUXER)            += mpeg.o
 OBJS-$(CONFIG_MPEGTS_DEMUXER)            += mpegts.o
 OBJS-$(CONFIG_MPEGTSRAW_DEMUXER)         += mpegts.o
-OBJS-$(CONFIG_MPEGTS_MUXER)              += mpegtsenc.o
+OBJS-$(CONFIG_MPEGTS_MUXER)              += mpegtsenc.o mpegpesenc.o
 OBJS-$(CONFIG_MPEGVIDEO_DEMUXER)         += raw.o
 OBJS-$(CONFIG_MPJPEG_MUXER)              += mpjpeg.o
 OBJS-$(CONFIG_MSNWC_TCP_DEMUXER)         += msnwc_tcp.o
Index: libavformat/mpegenc.c
===================================================================
--- libavformat/mpegenc.c	(revision 13661)
+++ libavformat/mpegenc.c	(working copy)
@@ -23,6 +23,7 @@
 #include "libavcodec/bitstream.h"
 #include "avformat.h"
 #include "mpeg.h"
+#include "mpegpes.h"
 
 #define MAX_PAYLOAD_SIZE 4096
 //#define DEBUG_SEEK
@@ -30,32 +31,7 @@
 #undef NDEBUG
 #include <assert.h>
 
-typedef struct PacketDesc {
-    int64_t pts;
-    int64_t dts;
-    int size;
-    int unwritten_size;
-    int flags;
-    struct PacketDesc *next;
-} PacketDesc;
-
 typedef struct {
-    AVFifoBuffer fifo;
-    uint8_t id;
-    int max_buffer_size; /* in bytes */
-    int buffer_index;
-    PacketDesc *predecode_packet;
-    PacketDesc *premux_packet;
-    PacketDesc **next_packet;
-    int packet_number;
-    uint8_t lpcm_header[3];
-    int lpcm_align;
-    int bytes_to_iframe;
-    int align_iframe;
-    int64_t vobu_start_pts;
-} StreamInfo;
-
-typedef struct {
     int packet_size; /* required packet size */
     int packet_number;
     int pack_header_freq;     /* frequency (in packets^-1) at which we send pack headers */
@@ -73,7 +49,7 @@
 
     double vcd_padding_bitrate; //FIXME floats
     int64_t vcd_padding_bytes_written;
-
+    uint8_t *payload; ///< PES packet buffer
 } MpegMuxContext;
 
 extern AVOutputFormat mpeg1vcd_muxer;
@@ -308,7 +284,9 @@
         s->packet_size = ctx->packet_size;
     else
         s->packet_size = 2048;
-
+    s->payload = av_mallocz(s->packet_size);
+    if (!s->payload)
+        return AVERROR(ENOMEM);
     s->vcd_padding_bytes_written = 0;
     s->vcd_padding_bitrate=0;
 
@@ -327,6 +305,11 @@
             goto fail;
         st->priv_data = stream;
 
+        /* set StreamInfo format */
+        if (s->is_dvd)   stream->format = PES_FMT_DVD;
+        if (s->is_svcd)  stream->format = PES_FMT_SVCD;
+        if (s->is_mpeg2) stream->format = PES_FMT_MPEG2;
+        if (s->is_vcd)   stream->format = PES_FMT_VCD;
         av_set_pts_info(st, 64, 1, 90000);
 
         switch(st->codec->codec_type) {
@@ -482,17 +465,6 @@
     return AVERROR(ENOMEM);
 }
 
-static inline void put_timestamp(ByteIOContext *pb, int id, int64_t timestamp)
-{
-    put_byte(pb,
-             (id << 4) |
-             (((timestamp >> 30) & 0x07) << 1) |
-             1);
-    put_be16(pb, (uint16_t)((((timestamp >> 15) & 0x7fff) << 1) | 1));
-    put_be16(pb, (uint16_t)((((timestamp) & 0x7fff) << 1) | 1));
-}
-
-
 /* return the number of padding bytes that should be inserted into
    the multiplexed stream.*/
 static int get_vcd_padding_size(AVFormatContext *ctx, int64_t pts)
@@ -621,20 +593,6 @@
         put_byte(pb, 0xff);
 }
 
-static int get_nb_frames(AVFormatContext *ctx, StreamInfo *stream, int len){
-    int nb_frames=0;
-    PacketDesc *pkt_desc= stream->premux_packet;
-
-    while(len>0){
-        if(pkt_desc->size == pkt_desc->unwritten_size)
-            nb_frames++;
-        len -= pkt_desc->unwritten_size;
-        pkt_desc= pkt_desc->next;
-    }
-
-    return nb_frames;
-}
-
 /* flush the packet on stream stream_index */
 static int flush_packet(AVFormatContext *ctx, int stream_index,
                          int64_t pts, int64_t dts, int64_t scr, int trailer_size)
@@ -642,14 +600,12 @@
     MpegMuxContext *s = ctx->priv_data;
     StreamInfo *stream = ctx->streams[stream_index]->priv_data;
     uint8_t *buf_ptr;
-    int size, payload_size, startcode, id, stuffing_size, i, header_len;
+    int size, payload_size, id, stuffing_size, i;
     int packet_size;
     uint8_t buffer[128];
     int zero_trail_bytes = 0;
     int pad_packet_bytes = 0;
-    int pes_flags;
     int general_pack = 0;  /*"general" pack without data specific to one stream?*/
-    int nb_frames;
 
     id = stream->id;
 
@@ -750,171 +706,14 @@
     packet_size -= pad_packet_bytes + zero_trail_bytes;
 
     if (packet_size > 0) {
-
-        /* packet header size */
-        packet_size -= 6;
-
-        /* packet header */
-        if (s->is_mpeg2) {
-            header_len = 3;
-            if (stream->packet_number==0)
-                header_len += 3; /* PES extension */
-            header_len += 1; /* obligatory stuffing byte */
-        } else {
-            header_len = 0;
-        }
-        if (pts != AV_NOPTS_VALUE) {
-            if (dts != pts)
-                header_len += 5 + 5;
-            else
-                header_len += 5;
-        } else {
-            if (!s->is_mpeg2)
-                header_len++;
-        }
-
-        payload_size = packet_size - header_len;
-        if (id < 0xc0) {
-            startcode = PRIVATE_STREAM_1;
-            payload_size -= 1;
-            if (id >= 0x40) {
-                payload_size -= 3;
-                if (id >= 0xa0)
-                    payload_size -= 3;
-            }
-        } else {
-            startcode = 0x100 + id;
-        }
-
-        stuffing_size = payload_size - av_fifo_size(&stream->fifo);
-
-        // first byte does not fit -> reset pts/dts + stuffing
-        if(payload_size <= trailer_size && pts != AV_NOPTS_VALUE){
-            int timestamp_len=0;
-            if(dts != pts)
-                timestamp_len += 5;
-            if(pts != AV_NOPTS_VALUE)
-                timestamp_len += s->is_mpeg2 ? 5 : 4;
-            pts=dts= AV_NOPTS_VALUE;
-            header_len -= timestamp_len;
-            if (s->is_dvd && stream->align_iframe) {
-                pad_packet_bytes += timestamp_len;
-                packet_size -= timestamp_len;
-            } else {
-                payload_size += timestamp_len;
-            }
-            stuffing_size += timestamp_len;
-            if(payload_size > trailer_size)
-                stuffing_size += payload_size - trailer_size;
-        }
-
-        if (pad_packet_bytes > 0 && pad_packet_bytes <= 7) { // can't use padding, so use stuffing
-            packet_size += pad_packet_bytes;
-            payload_size += pad_packet_bytes; // undo the previous adjustment
-            if (stuffing_size < 0) {
-                stuffing_size = pad_packet_bytes;
-            } else {
-                stuffing_size += pad_packet_bytes;
-            }
-            pad_packet_bytes = 0;
-        }
-
-        if (stuffing_size < 0)
-            stuffing_size = 0;
-        if (stuffing_size > 16) {    /*<=16 for MPEG-1, <=32 for MPEG-2*/
-            pad_packet_bytes += stuffing_size;
-            packet_size -= stuffing_size;
-            payload_size -= stuffing_size;
-            stuffing_size = 0;
-        }
-
-        nb_frames= get_nb_frames(ctx, stream, payload_size - stuffing_size);
-
-        put_be32(ctx->pb, startcode);
-
-        put_be16(ctx->pb, packet_size);
-
-        if (!s->is_mpeg2)
-            for(i=0;i<stuffing_size;i++)
-                put_byte(ctx->pb, 0xff);
-
-        if (s->is_mpeg2) {
-            put_byte(ctx->pb, 0x80); /* mpeg2 id */
-
-            pes_flags=0;
-
-            if (pts != AV_NOPTS_VALUE) {
-                pes_flags |= 0x80;
-                if (dts != pts)
-                    pes_flags |= 0x40;
-            }
-
-            /* Both the MPEG-2 and the SVCD standards demand that the
-               P-STD_buffer_size field be included in the first packet of
-               every stream. (see SVCD standard p. 26 V.2.3.1 and V.2.3.2
-               and MPEG-2 standard 2.7.7) */
-            if (stream->packet_number == 0)
-                pes_flags |= 0x01;
-
-            put_byte(ctx->pb, pes_flags); /* flags */
-            put_byte(ctx->pb, header_len - 3 + stuffing_size);
-
-            if (pes_flags & 0x80)  /*write pts*/
-                put_timestamp(ctx->pb, (pes_flags & 0x40) ? 0x03 : 0x02, pts);
-            if (pes_flags & 0x40)  /*write dts*/
-                put_timestamp(ctx->pb, 0x01, dts);
-
-            if (pes_flags & 0x01) {  /*write pes extension*/
-                put_byte(ctx->pb, 0x10); /* flags */
-
-                /* P-STD buffer info */
-                if (id == AUDIO_ID)
-                    put_be16(ctx->pb, 0x4000 | stream->max_buffer_size/128);
-                else
-                    put_be16(ctx->pb, 0x6000 | stream->max_buffer_size/1024);
-            }
-
-        } else {
-            if (pts != AV_NOPTS_VALUE) {
-                if (dts != pts) {
-                    put_timestamp(ctx->pb, 0x03, pts);
-                    put_timestamp(ctx->pb, 0x01, dts);
-                } else {
-                    put_timestamp(ctx->pb, 0x02, pts);
-                }
-            } else {
-                put_byte(ctx->pb, 0x0f);
-            }
-        }
-
-        if (s->is_mpeg2) {
-            /* special stuffing byte that is always written
-               to prevent accidental generation of start codes. */
-            put_byte(ctx->pb, 0xff);
-
-            for(i=0;i<stuffing_size;i++)
-                put_byte(ctx->pb, 0xff);
-        }
-
-        if (startcode == PRIVATE_STREAM_1) {
-            put_byte(ctx->pb, id);
-            if (id >= 0xa0) {
-                /* LPCM (XXX: check nb_frames) */
-                put_byte(ctx->pb, 7);
-                put_be16(ctx->pb, 4); /* skip 3 header bytes */
-                put_byte(ctx->pb, stream->lpcm_header[0]);
-                put_byte(ctx->pb, stream->lpcm_header[1]);
-                put_byte(ctx->pb, stream->lpcm_header[2]);
-            } else if (id >= 0x40) {
-                /* AC3 */
-                put_byte(ctx->pb, nb_frames);
-                put_be16(ctx->pb, trailer_size+1);
-            }
-        }
-
+        int pes_size = ff_pes_write_buf(ctx, stream_index, s->payload,
+                                        &pts, &dts, trailer_size,
+                                        &packet_size, &pad_packet_bytes,
+                                        &payload_size, &stuffing_size);
+        if(pes_size < 0)
+            return -1;
         /* output data */
-        assert(payload_size - stuffing_size <= av_fifo_size(&stream->fifo));
-        av_fifo_generic_read(&stream->fifo, payload_size - stuffing_size, &put_buffer, ctx->pb);
+        put_buffer(ctx->pb, s->payload, pes_size);
         stream->bytes_to_iframe -= payload_size - stuffing_size;
     }else{
         payload_size=
@@ -987,130 +786,18 @@
 }
 #endif
 
-static int remove_decoded_packets(AVFormatContext *ctx, int64_t scr){
-//    MpegMuxContext *s = ctx->priv_data;
-    int i;
-
-    for(i=0; i<ctx->nb_streams; i++){
-        AVStream *st = ctx->streams[i];
-        StreamInfo *stream = st->priv_data;
-        PacketDesc *pkt_desc;
-
-        while((pkt_desc= stream->predecode_packet)
-              && scr > pkt_desc->dts){ //FIXME > vs >=
-            if(stream->buffer_index < pkt_desc->size ||
-               stream->predecode_packet == stream->premux_packet){
-                av_log(ctx, AV_LOG_ERROR,
-                       "buffer underflow i=%d bufi=%d size=%d\n",
-                       i, stream->buffer_index, pkt_desc->size);
-                break;
-            }
-            stream->buffer_index -= pkt_desc->size;
-
-            stream->predecode_packet= pkt_desc->next;
-            av_freep(&pkt_desc);
-        }
-    }
-
-    return 0;
-}
-
 static int output_packet(AVFormatContext *ctx, int flush){
     MpegMuxContext *s = ctx->priv_data;
-    AVStream *st;
     StreamInfo *stream;
-    int i, avail_space=0, es_size, trailer_size;
+    int es_size;
     int best_i= -1;
-    int best_score= INT_MIN;
-    int ignore_constraints=0;
     int64_t scr= s->last_scr;
-    PacketDesc *timestamp_packet;
-    const int64_t max_delay= av_rescale(ctx->max_delay, 90000, AV_TIME_BASE);
 
-retry:
-    for(i=0; i<ctx->nb_streams; i++){
-        AVStream *st = ctx->streams[i];
-        StreamInfo *stream = st->priv_data;
-        const int avail_data=  av_fifo_size(&stream->fifo);
-        const int space= stream->max_buffer_size - stream->buffer_index;
-        int rel_space= 1024*space / stream->max_buffer_size;
-        PacketDesc *next_pkt= stream->premux_packet;
+    if ((es_size = ff_pes_output_packet(ctx, s->packet_size, &scr, &best_i,
+                                        flush, flush_packet)) <= 0)
+        return es_size;
+    stream= ctx->streams[best_i]->priv_data;
 
-        /* for subtitle, a single PES packet must be generated,
-           so we flush after every single subtitle packet */
-        if(s->packet_size > avail_data && !flush
-           && st->codec->codec_type != CODEC_TYPE_SUBTITLE)
-            return 0;
-        if(avail_data==0)
-            continue;
-        assert(avail_data>0);
-
-        if(space < s->packet_size && !ignore_constraints)
-            continue;
-
-        if(next_pkt && next_pkt->dts - scr > max_delay)
-            continue;
-
-        if(rel_space > best_score){
-            best_score= rel_space;
-            best_i = i;
-            avail_space= space;
-        }
-    }
-
-    if(best_i < 0){
-        int64_t best_dts= INT64_MAX;
-
-        for(i=0; i<ctx->nb_streams; i++){
-            AVStream *st = ctx->streams[i];
-            StreamInfo *stream = st->priv_data;
-            PacketDesc *pkt_desc= stream->predecode_packet;
-            if(pkt_desc && pkt_desc->dts < best_dts)
-                best_dts= pkt_desc->dts;
-        }
-
-#if 0
-        av_log(ctx, AV_LOG_DEBUG, "bumping scr, scr:%f, dts:%f\n",
-               scr/90000.0, best_dts/90000.0);
-#endif
-        if(best_dts == INT64_MAX)
-            return 0;
-
-        if(scr >= best_dts+1 && !ignore_constraints){
-            av_log(ctx, AV_LOG_ERROR, "packet too large, ignoring buffer limits to mux it\n");
-            ignore_constraints= 1;
-        }
-        scr= FFMAX(best_dts+1, scr);
-        if(remove_decoded_packets(ctx, scr) < 0)
-            return -1;
-        goto retry;
-    }
-
-    assert(best_i >= 0);
-
-    st = ctx->streams[best_i];
-    stream = st->priv_data;
-
-    assert(av_fifo_size(&stream->fifo) > 0);
-
-    assert(avail_space >= s->packet_size || ignore_constraints);
-
-    timestamp_packet= stream->premux_packet;
-    if(timestamp_packet->unwritten_size == timestamp_packet->size){
-        trailer_size= 0;
-    }else{
-        trailer_size= timestamp_packet->unwritten_size;
-        timestamp_packet= timestamp_packet->next;
-    }
-
-    if(timestamp_packet){
-//av_log(ctx, AV_LOG_DEBUG, "dts:%f pts:%f scr:%f stream:%d\n", timestamp_packet->dts/90000.0, timestamp_packet->pts/90000.0, scr/90000.0, best_i);
-        es_size= flush_packet(ctx, best_i, timestamp_packet->pts, timestamp_packet->dts, scr, trailer_size);
-    }else{
-        assert(av_fifo_size(&stream->fifo) == trailer_size);
-        es_size= flush_packet(ctx, best_i, AV_NOPTS_VALUE, AV_NOPTS_VALUE, scr, trailer_size);
-    }
-
     if (s->is_vcd) {
         /* Write one or more padding sectors, if necessary, to reach
            the constant overall bitrate.*/
@@ -1132,7 +819,7 @@
     if(es_size)
         stream->premux_packet->unwritten_size -= es_size;
 
-    if(remove_decoded_packets(ctx, s->last_scr) < 0)
+    if(ff_pes_remove_decoded_packets(ctx, s->last_scr) < 0)
         return -1;
 
     return 1;
@@ -1141,47 +828,7 @@
 static int mpeg_mux_write_packet(AVFormatContext *ctx, AVPacket *pkt)
 {
     MpegMuxContext *s = ctx->priv_data;
-    int stream_index= pkt->stream_index;
-    int size= pkt->size;
-    uint8_t *buf= pkt->data;
-    AVStream *st = ctx->streams[stream_index];
-    StreamInfo *stream = st->priv_data;
-    int64_t pts, dts;
-    PacketDesc *pkt_desc;
-    const int preload= av_rescale(ctx->preload, 90000, AV_TIME_BASE);
-    const int is_iframe = st->codec->codec_type == CODEC_TYPE_VIDEO && (pkt->flags & PKT_FLAG_KEY);
-
-    pts= pkt->pts;
-    dts= pkt->dts;
-
-    if(pts != AV_NOPTS_VALUE) pts += preload;
-    if(dts != AV_NOPTS_VALUE) dts += preload;
-
-//av_log(ctx, AV_LOG_DEBUG, "dts:%f pts:%f flags:%d stream:%d nopts:%d\n", dts/90000.0, pts/90000.0, pkt->flags, pkt->stream_index, pts != AV_NOPTS_VALUE);
-    if (!stream->premux_packet)
-        stream->next_packet = &stream->premux_packet;
-    *stream->next_packet=
-    pkt_desc= av_mallocz(sizeof(PacketDesc));
-    pkt_desc->pts= pts;
-    pkt_desc->dts= dts;
-    pkt_desc->unwritten_size=
-    pkt_desc->size= size;
-    if(!stream->predecode_packet)
-        stream->predecode_packet= pkt_desc;
-    stream->next_packet= &pkt_desc->next;
-
-    av_fifo_realloc(&stream->fifo, av_fifo_size(&stream->fifo) + size);
-
-    if (s->is_dvd){
-        if (is_iframe && (s->packet_number == 0 || (pts - stream->vobu_start_pts >= 36000))) { // min VOBU length 0.4 seconds (mpucoder)
-            stream->bytes_to_iframe = av_fifo_size(&stream->fifo);
-            stream->align_iframe = 1;
-            stream->vobu_start_pts = pts;
-        }
-    }
-
-    av_fifo_generic_write(&stream->fifo, buf, size, NULL);
-
+    ff_pes_write_packet(ctx, pkt, s->packet_number);
     for(;;){
         int ret= output_packet(ctx, 0);
         if(ret<=0)
@@ -1191,9 +838,7 @@
 
 static int mpeg_mux_end(AVFormatContext *ctx)
 {
-//    MpegMuxContext *s = ctx->priv_data;
-    StreamInfo *stream;
-    int i;
+    MpegMuxContext *s = ctx->priv_data;
 
     for(;;){
         int ret= output_packet(ctx, 1);
@@ -1209,12 +854,9 @@
     //put_be32(ctx->pb, ISO_11172_END_CODE);
     //put_flush_packet(ctx->pb);
 
-    for(i=0;i<ctx->nb_streams;i++) {
-        stream = ctx->streams[i]->priv_data;
+    ff_pes_muxer_end(ctx);
 
-        assert(av_fifo_size(&stream->fifo) == 0);
-        av_fifo_free(&stream->fifo);
-    }
+    av_free(s->payload);
     return 0;
 }
 
Index: libavformat/mpegtsenc.c
===================================================================
--- libavformat/mpegtsenc.c	(revision 13661)
+++ libavformat/mpegtsenc.c	(working copy)
@@ -22,6 +22,8 @@
 #include "libavutil/crc.h"
 #include "avformat.h"
 #include "mpegts.h"
+#include "libavcodec/bytestream.h"
+#include "mpegpes.h"
 
 /* write DVB SI sections */
 
@@ -136,9 +138,10 @@
 /* we retransmit the SI info at this rate */
 #define SDT_RETRANS_TIME 500
 #define PAT_RETRANS_TIME 100
-#define PCR_RETRANS_TIME 20
+#define MAX_DELTA_PCR 9000 /**< 0.1s according to ISO 13818-1 */
 
 typedef struct MpegTSWriteStream {
+    StreamInfo pes;
     struct MpegTSService *service;
     int pid; /* stream associated pid */
     int cc;
@@ -154,8 +157,6 @@
     char *name;
     char *provider_name;
     int pcr_pid;
-    int pcr_packet_count;
-    int pcr_packet_freq;
 } MpegTSService;
 
 typedef struct MpegTSWrite {
@@ -169,6 +170,9 @@
     int nb_services;
     int onid;
     int tsid;
+    int64_t last_pcr; ///< last program clock reference */
+    int64_t cur_pcr;  ///< last program clock reference */
+    int mux_rate;
 } MpegTSWrite;
 
 static void mpegts_write_pat(AVFormatContext *s)
@@ -390,6 +394,7 @@
     /* assign pids to each stream */
     total_bit_rate = 0;
     for(i = 0;i < s->nb_streams; i++) {
+        int codec_rate;
         st = s->streams[i];
         ts_st = av_mallocz(sizeof(MpegTSWriteStream));
         if (!ts_st)
@@ -403,7 +408,29 @@
         if (st->codec->codec_type == CODEC_TYPE_VIDEO &&
             service->pcr_pid == 0x1fff)
             service->pcr_pid = ts_st->pid;
-        total_bit_rate += st->codec->bit_rate;
+
+        if (st->codec->codec_type == CODEC_TYPE_VIDEO) {
+            ts_st->pes.id = 0xe0;
+        } else if (st->codec->codec_type == CODEC_TYPE_AUDIO &&
+                   (st->codec->codec_id == CODEC_ID_MP2 ||
+                    st->codec->codec_id == CODEC_ID_MP3)) {
+            ts_st->pes.id = 0xc0;
+        } else {
+            ts_st->pes.id = 0xbd;
+            if (st->codec->codec_type == CODEC_TYPE_SUBTITLE) {
+                //private_code = 0x20;
+            }
+        }
+
+        ts_st->pes.format = PES_FMT_TS;
+
+        if(st->codec->rc_max_rate)
+            codec_rate= st->codec->rc_max_rate;
+        else
+            codec_rate= st->codec->bit_rate;
+        if(!codec_rate)
+            codec_rate= (1<<21)*8/s->nb_streams;
+        total_bit_rate += codec_rate;
     }
 
     /* if no video stream, use the first stream as PCR */
@@ -412,10 +439,20 @@
         service->pcr_pid = ts_st->pid;
     }
 
-    if (total_bit_rate <= 8 * 1024)
-        total_bit_rate = 8 * 1024;
-    service->pcr_packet_freq = (total_bit_rate * PCR_RETRANS_TIME) /
-        (TS_PACKET_SIZE * 8 * 1000);
+    if(ff_pes_muxer_init(s) != 0)
+        goto fail;
+
+    if(s->mux_rate) {
+        ts->mux_rate= s->mux_rate;
+    } else {
+        total_bit_rate +=
+            total_bit_rate * 25 / (8 * DEFAULT_PES_PAYLOAD_SIZE) + /* PES header size */
+            total_bit_rate * 4 / (8 * TS_PACKET_SIZE) +            /* TS  header size */
+            SDT_RETRANS_TIME * 12 +                                /* SDT size */
+            PAT_RETRANS_TIME * 16;                                 /* PAT size */
+        ts->mux_rate = total_bit_rate;
+    }
+
     ts->sdt_packet_freq = (total_bit_rate * SDT_RETRANS_TIME) /
         (TS_PACKET_SIZE * 8 * 1000);
     ts->pat_packet_freq = (total_bit_rate * PAT_RETRANS_TIME) /
@@ -463,60 +500,44 @@
     }
 }
 
-static void write_pts(uint8_t *q, int fourbits, int64_t pts)
-{
-    int val;
-
-    val = fourbits << 4 | (((pts >> 30) & 0x07) << 1) | 1;
-    *q++ = val;
-    val = (((pts >> 15) & 0x7fff) << 1) | 1;
-    *q++ = val >> 8;
-    *q++ = val;
-    val = (((pts) & 0x7fff) << 1) | 1;
-    *q++ = val >> 8;
-    *q++ = val;
-}
-
 /* NOTE: pes_data contains all the PES packet */
 static void mpegts_write_pes(AVFormatContext *s, AVStream *st,
-                             const uint8_t *payload, int payload_size,
-                             int64_t pts, int64_t dts)
+                             int64_t pcr, const uint8_t *payload, int payload_size)
 {
     MpegTSWriteStream *ts_st = st->priv_data;
+    MpegTSWrite *ts = s->priv_data;
     uint8_t buf[TS_PACKET_SIZE];
     uint8_t *q;
-    int val, is_start, len, header_len, write_pcr, private_code, flags;
+    int val, is_start, len, header_len, write_pcr;
     int afc_len, stuffing_len;
-    int64_t pcr = -1; /* avoid warning */
 
     is_start = 1;
+    ts->cur_pcr = pcr;
     while (payload_size > 0) {
         retransmit_si_info(s);
 
-        write_pcr = 0;
+        write_pcr = !ts->cur_pcr;
         if (ts_st->pid == ts_st->service->pcr_pid) {
-            ts_st->service->pcr_packet_count++;
-            if (ts_st->service->pcr_packet_count >=
-                ts_st->service->pcr_packet_freq) {
-                ts_st->service->pcr_packet_count = 0;
+            pcr = ts->cur_pcr + (TS_PACKET_SIZE+4+7)*8*90000LL / ts->mux_rate;
+            if (pcr - ts->last_pcr > MAX_DELTA_PCR)
                 write_pcr = 1;
-                /* XXX: this is incorrect, but at least we have a PCR
-                   value */
-                pcr = pts;
-            }
         }
 
         /* prepare packet header */
         q = buf;
         *q++ = 0x47;
         val = (ts_st->pid >> 8);
-        if (is_start)
+        if (is_start) {
             val |= 0x40;
+            is_start = 0;
+        }
         *q++ = val;
         *q++ = ts_st->pid;
         *q++ = 0x10 | ts_st->cc | (write_pcr ? 0x20 : 0);
         ts_st->cc = (ts_st->cc + 1) & 0xf;
         if (write_pcr) {
+            /* add header and pcr bytes to pcr according to specs */
+            pcr = ts->cur_pcr + (4+7)*8*90000LL / ts->mux_rate;
             *q++ = 7; /* AFC length */
             *q++ = 0x10; /* flags: PCR present */
             *q++ = pcr >> 25;
@@ -525,59 +546,8 @@
             *q++ = pcr >> 1;
             *q++ = (pcr & 1) << 7;
             *q++ = 0;
+            ts->last_pcr = pcr;
         }
-        if (is_start) {
-            /* write PES header */
-            *q++ = 0x00;
-            *q++ = 0x00;
-            *q++ = 0x01;
-            private_code = 0;
-            if (st->codec->codec_type == CODEC_TYPE_VIDEO) {
-                *q++ = 0xe0;
-            } else if (st->codec->codec_type == CODEC_TYPE_AUDIO &&
-                       (st->codec->codec_id == CODEC_ID_MP2 ||
-                        st->codec->codec_id == CODEC_ID_MP3)) {
-                *q++ = 0xc0;
-            } else {
-                *q++ = 0xbd;
-                if (st->codec->codec_type == CODEC_TYPE_SUBTITLE) {
-                    private_code = 0x20;
-                }
-            }
-            header_len = 0;
-            flags = 0;
-            if (pts != AV_NOPTS_VALUE) {
-                header_len += 5;
-                flags |= 0x80;
-            }
-            if (dts != AV_NOPTS_VALUE) {
-                header_len += 5;
-                flags |= 0x40;
-            }
-            len = payload_size + header_len + 3;
-            if (private_code != 0)
-                len++;
-            *q++ = len >> 8;
-            *q++ = len;
-            val = 0x80;
-            /* data alignment indicator is required for subtitle data */
-            if (st->codec->codec_type == CODEC_TYPE_SUBTITLE)
-                val |= 0x04;
-            *q++ = val;
-            *q++ = flags;
-            *q++ = header_len;
-            if (pts != AV_NOPTS_VALUE) {
-                write_pts(q, flags >> 6, pts);
-                q += 5;
-            }
-            if (dts != AV_NOPTS_VALUE) {
-                write_pts(q, 1, dts);
-                q += 5;
-            }
-            if (private_code != 0)
-                *q++ = private_code;
-            is_start = 0;
-        }
         /* header size */
         header_len = q - buf;
         /* data len */
@@ -610,67 +580,113 @@
         payload += len;
         payload_size -= len;
         put_buffer(s->pb, buf, TS_PACKET_SIZE);
+        ts->cur_pcr += (TS_PACKET_SIZE+write_pcr)*8*90000LL / ts->mux_rate;
     }
     put_flush_packet(s->pb);
 }
 
-static int mpegts_write_packet(AVFormatContext *s, AVPacket *pkt)
+static void put_padding_packet(uint8_t **pes_payload, int packet_bytes)
 {
-    AVStream *st = s->streams[pkt->stream_index];
-    int size= pkt->size;
-    uint8_t *buf= pkt->data;
-    MpegTSWriteStream *ts_st = st->priv_data;
-    int len, max_payload_size;
+    int i;
 
-    if (st->codec->codec_type == CODEC_TYPE_SUBTITLE) {
-        /* for subtitle, a single PES packet must be generated */
-        mpegts_write_pes(s, st, buf, size, pkt->pts, AV_NOPTS_VALUE);
-        return 0;
+    bytestream_put_be32(pes_payload, PADDING_STREAM);
+    bytestream_put_be16(pes_payload, packet_bytes - 6);
+    packet_bytes -= 6;
+
+    for(i=0;i<packet_bytes;i++)
+        bytestream_put_byte(pes_payload, 0xff);
+}
+
+/* flush the packet on stream stream_index */
+static int flush_packet(AVFormatContext *ctx, int stream_index,
+                        int64_t pts, int64_t dts, int64_t pcr, int trailer_size)
+{
+    MpegTSWriteStream *stream = ctx->streams[stream_index]->priv_data;
+    int payload_size, stuffing_size, i;
+    int packet_size;
+    int zero_trail_bytes = 0;
+    int pad_packet_bytes = 0;
+    uint8_t *q = stream->payload;
+
+    packet_size = DEFAULT_PES_PAYLOAD_SIZE;
+
+    if (packet_size > 0) {
+        int pes_size = ff_pes_write_buf(ctx, stream_index, stream->payload,
+                                        &pts, &dts, trailer_size,
+                                        &packet_size, &pad_packet_bytes,
+                                        &payload_size, &stuffing_size);
+        if(pes_size < 0)
+            return -1;
+        q += pes_size;
+    }else{
+        payload_size=
+        stuffing_size= 0;
     }
 
-    max_payload_size = DEFAULT_PES_PAYLOAD_SIZE;
-    while (size > 0) {
-        len = max_payload_size - ts_st->payload_index;
-        if (len > size)
-            len = size;
-        memcpy(ts_st->payload + ts_st->payload_index, buf, len);
-        buf += len;
-        size -= len;
-        ts_st->payload_index += len;
-        if (ts_st->payload_pts == AV_NOPTS_VALUE)
-            ts_st->payload_pts = pkt->pts;
-        if (ts_st->payload_dts == AV_NOPTS_VALUE)
-            ts_st->payload_dts = pkt->dts;
-        if (ts_st->payload_index >= max_payload_size) {
-            mpegts_write_pes(s, st, ts_st->payload, ts_st->payload_index,
-                             ts_st->payload_pts, ts_st->payload_dts);
-            ts_st->payload_pts = AV_NOPTS_VALUE;
-            ts_st->payload_dts = AV_NOPTS_VALUE;
-            ts_st->payload_index = 0;
-        }
+    if (pad_packet_bytes > 0)
+        put_padding_packet(&q, pad_packet_bytes);
+
+    for(i=0;i<zero_trail_bytes;i++)
+        bytestream_put_byte(&q, 0x00);
+
+    mpegts_write_pes(ctx, ctx->streams[stream_index], pcr,
+                     stream->payload, q - stream->payload);
+
+    return payload_size - stuffing_size;
+}
+
+static int output_packet(AVFormatContext *ctx, int flush){
+    MpegTSWrite *s = ctx->priv_data;
+    StreamInfo *stream;
+    int es_size;
+    int best_i= -1;
+    int64_t pcr= s->last_pcr;
+
+    if ((es_size = ff_pes_output_packet(ctx, DEFAULT_PES_PAYLOAD_SIZE,
+                                        &pcr, &best_i, flush, flush_packet)) <= 0)
+        return es_size;
+    stream= ctx->streams[best_i]->priv_data;
+
+    stream->buffer_index += es_size;
+    while(stream->premux_packet && stream->premux_packet->unwritten_size <= es_size){
+        es_size -= stream->premux_packet->unwritten_size;
+        stream->premux_packet= stream->premux_packet->next;
     }
-    return 0;
+    if(es_size)
+        stream->premux_packet->unwritten_size -= es_size;
+
+    if(ff_pes_remove_decoded_packets(ctx, s->last_pcr) < 0)
+        return -1;
+
+    return 1;
 }
 
+
+static int mpegts_write_packet(AVFormatContext *ctx, AVPacket *pkt)
+{
+    ff_pes_write_packet(ctx, pkt, 0);
+    for(;;){
+        int ret = output_packet(ctx, 0);
+        if(ret<=0)
+            return ret;
+    }
+}
+
 static int mpegts_write_end(AVFormatContext *s)
 {
     MpegTSWrite *ts = s->priv_data;
-    MpegTSWriteStream *ts_st;
     MpegTSService *service;
-    AVStream *st;
     int i;
 
-    /* flush current packets */
-    for(i = 0; i < s->nb_streams; i++) {
-        st = s->streams[i];
-        ts_st = st->priv_data;
-        if (ts_st->payload_index > 0) {
-            mpegts_write_pes(s, st, ts_st->payload, ts_st->payload_index,
-                             ts_st->payload_pts, ts_st->payload_dts);
-        }
+    for(;;){
+        int ret= output_packet(s, 1);
+        if(ret<0)
+            return ret;
+        else if(ret==0)
+            break;
     }
-    put_flush_packet(s->pb);
 
+    ff_pes_muxer_end(s);
     for(i = 0; i < ts->nb_services; i++) {
         service = ts->services[i];
         av_freep(&service->provider_name);
