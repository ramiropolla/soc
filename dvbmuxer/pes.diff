Index: libavformat/pes.c
===================================================================
--- libavformat/pes.c	(revision 0)
+++ libavformat/pes.c	(revision 0)
@@ -0,0 +1,395 @@
+/*
+ * PES muxer.
+ * Copyright (c) 2007 Xiaohui Sun <sunxiaohui@dsp.ac.cn>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "pes.h"
+#include "bytestream.h"
+
+
+/*
+ * Put timestamp into packet
+ * @param[in] p         the stream to write
+ * @param[in] id        stream id
+ * @param[in] timestamp the timestamp to put in
+ * @return  NULL
+ */
+static inline void put_timestamp(uint8_t* p, int id, int64_t timestamp)
+{
+    bytestream_put_byte(&p,
+        (id << 4) |
+        (((timestamp >> 30) & 0x07) << 1) |
+        1);
+    bytestream_put_be16(&p, (uint16_t)((((timestamp >> 15) & 0x7fff) << 1) | 1));
+    bytestream_put_be16(&p, (uint16_t)((((timestamp) & 0x7fff) << 1) | 1));
+}
+
+static int get_nb_frames(AVFormatContext *ctx, PESStream *stream, int len){
+    int nb_frames=0;
+    PacketDesc *pkt_desc= stream->premux_packet;
+
+    while(len>0){
+        if(pkt_desc->size == pkt_desc->unwritten_size)
+            nb_frames++;
+        len -= pkt_desc->unwritten_size;
+        pkt_desc= pkt_desc->next;
+    }
+
+    return nb_frames;
+}
+
+/*
+ * Initialization of PES mux.
+ * @param[in] ctx the AVFormatContext which contains streams
+ * @return  On error a negative value is returned, on success zero.
+ */
+int pes_mux_init(AVFormatContext *ctx)
+{
+    AVStream *st;
+    PESStream *stream;
+    int i, j;
+    int mpa_id, mpv_id, mps_id, ac3_id, dts_id, lpcm_id;
+
+    mpa_id = AUDIO_ID;
+    ac3_id = AC3_ID;
+    dts_id = DTS_ID;
+    mpv_id = VIDEO_ID;
+    mps_id = SUB_ID;
+    lpcm_id = LPCM_ID;
+
+    for (i = 0; i < ctx->nb_streams; i++) {
+        st = ctx->streams[i];
+        stream = (PESStream*)st->priv_data;
+        av_set_pts_info(st, 64, 1, 90000);
+
+        switch(st->codec->codec_type) {
+        case CODEC_TYPE_AUDIO:
+            if (st->codec->codec_id == CODEC_ID_AC3) {
+                stream->id = ac3_id++;
+            } else if (st->codec->codec_id == CODEC_ID_DTS) {
+                stream->id = dts_id++;
+            } else if (st->codec->codec_id == CODEC_ID_PCM_S16BE) {
+                stream->id = lpcm_id++;
+                for(j = 0; j < 4; j++) {
+                    if (lpcm_freq_tab[j] == st->codec->sample_rate)
+                        break;
+                }
+                if (j == 4)
+                    return AVERROR(ENOMEM);
+                if (st->codec->channels > 8)
+                    return -1;
+                stream->lpcm_header[0] = 0x0c;
+                stream->lpcm_header[1] = (st->codec->channels - 1) | (j << 4);
+                stream->lpcm_header[2] = 0x80;
+                stream->lpcm_align = st->codec->channels * 2;
+            } else {
+                stream->id = mpa_id++;
+            }
+            /* This value HAS to be used for VCD (see VCD standard, p. IV-7).
+             Right now it is also used for everything else.*/
+            stream->max_buffer_size = 4 * 1024;
+
+            break;
+        case CODEC_TYPE_VIDEO:
+            stream->id = mpv_id++;
+#if 0
+                /* see VCD standard, p. IV-7*/
+                stream->max_buffer_size = 46 * 1024;
+            else
+                /* This value HAS to be used for SVCD (see SVCD standard, p. 26 V.2.3.2).
+                   Right now it is also used for everything else.*/
+                stream->max_buffer_size = 230 * 1024;
+#endif
+            if (st->codec->rc_buffer_size)
+                stream->max_buffer_size = 6*1024 + st->codec->rc_buffer_size/8;
+            else
+                stream->max_buffer_size = 230*1024; //FIXME this is probably too small as default
+            break;
+        case CODEC_TYPE_SUBTITLE:
+            stream->id = mps_id++;
+            stream->max_buffer_size = 16 * 1024;
+            break;
+        default:
+            return -1;
+        }
+
+        av_fifo_init(&stream->fifo, 16);
+    }
+    return 0;
+}
+
+
+/*
+ * Finalization of PES mux.
+ * @param [in] ctx the AVFormatContext which contains streams.
+ * @return  NULL
+ */
+void pes_mux_end(AVFormatContext *ctx)
+{
+    PESStream *stream;
+    int i;
+
+    for (i = 0; i < ctx->nb_streams; i++) {
+        stream = ctx->streams[i]->priv_data;
+        assert(av_fifo_size(&stream->fifo) == 0);
+        av_fifo_free(&stream->fifo);
+    }
+}
+
+/*
+ * Write packet into PES fifo.
+ * @param [in] ctx  the AVFormatContext which contains streams.
+ * @param [in] pkt  the packet to write.
+ * @return  NULL
+ */
+void pes_write_packet(AVFormatContext *ctx, AVPacket *pkt)
+{
+    int stream_index= pkt->stream_index;
+    AVStream *st = ctx->streams[stream_index];
+    PESStream *stream = st->priv_data;
+    int size= pkt->size;
+    uint8_t *buf= pkt->data;
+    PacketDesc *pkt_desc;
+    int64_t pts, dts;
+    const int preload= av_rescale(ctx->preload, 90000, AV_TIME_BASE);
+
+    pts= pkt->pts;
+    dts= pkt->dts;
+
+    if (pts != AV_NOPTS_VALUE)
+        pts += preload;
+    if (dts != AV_NOPTS_VALUE)
+        dts += preload;
+
+    if (!stream->premux_packet)
+        stream->next_packet = &stream->premux_packet;
+    *stream->next_packet=
+        pkt_desc= av_mallocz(sizeof(PacketDesc));
+    pkt_desc->pts= pkt->pts;
+    pkt_desc->dts= pkt->dts;
+    pkt_desc->unwritten_size=
+        pkt_desc->size= size;
+    if (!stream->predecode_packet)
+        stream->predecode_packet= pkt_desc;
+    stream->next_packet= &pkt_desc->next;
+
+    av_fifo_realloc(&stream->fifo, av_fifo_size(&stream->fifo) + size + 1);
+    av_fifo_write(&stream->fifo, buf, size);
+}
+
+
+/*
+ * Find the most fit stream to be muxed.
+ * @param[in]  ctx          the AVFormatContext
+ * @param[in]  packet_size  the packet size of PES stream
+ * @param[in]  flush        whether we flush after every single subtitle packet for subtitle
+ * @param[out] best_i       the best fit stream index
+ * @return     On error a negative or zero value is returned, on success 1 is returned
+ */
+int pes_find_beststream(AVFormatContext *ctx, int packet_size, int flush, int64_t scr, int* best_i)
+{
+    int best_score = INT_MIN;
+    int i, avail_space = 0;
+    int ignore_constraints = 0;
+    const int64_t max_delay= av_rescale(ctx->max_delay, 90000, AV_TIME_BASE);
+
+retry:
+    for (i = 0; i < ctx->nb_streams; i++){
+        AVStream *st = ctx->streams[i];
+        PESStream*stream = st->priv_data;
+        const int avail_data =  av_fifo_size(&stream->fifo);
+        const int space = stream->max_buffer_size - stream->buffer_index;
+        int rel_space = 1024*space / stream->max_buffer_size;
+        PacketDesc *next_pkt = stream->premux_packet;
+
+        /* for subtitle, a single PES packet must be generated,
+          so we flush after every single subtitle packet */
+        if (packet_size > avail_data && !flush
+            && st->codec->codec_type != CODEC_TYPE_SUBTITLE)
+            return 0;
+        if (avail_data == 0)
+            continue;
+        assert(avail_data > 0);
+
+        if (space < packet_size && !ignore_constraints)
+            continue;
+
+        if (next_pkt && next_pkt->dts - scr > max_delay)
+            continue;
+
+        if (rel_space > best_score){
+            best_score= rel_space;
+            *best_i = i;
+            avail_space = space;
+        }
+    }
+
+    if (*best_i < 0){
+      int64_t best_dts = INT64_MAX;
+
+    for (i = 0; i < ctx->nb_streams; i++){
+        AVStream *st = ctx->streams[i];
+        PESStream *stream = st->priv_data;
+        PacketDesc *pkt_desc = stream->predecode_packet;
+        if (pkt_desc && pkt_desc->dts < best_dts)
+            best_dts = pkt_desc->dts;
+    }
+
+#if 0
+        av_log(ctx, AV_LOG_DEBUG, "bumping scr, scr:%f, dts:%f\n",
+            scr/90000.0, best_dts/90000.0);
+#endif
+
+        if (best_dts == INT64_MAX)
+            return 0;
+
+        if (scr >= best_dts+1 && !ignore_constraints){
+          av_log(ctx, AV_LOG_ERROR, "packet too large, ignoring buffer limits to mux it\n");
+          ignore_constraints = 1;
+        }
+        scr= FFMAX(best_dts+1, scr);
+        pes_remove_decoded_packets(ctx, scr);
+        goto retry;
+    }
+    assert(avail_space >= packet_size || ignore_constraints);
+    return 1;
+}
+
+
+/*
+ * Mux streams into a PES packet.
+ * @param [in]      ctx            the AVFormatContext which contains streams
+ * @param [in]      stream_index   the stream index to write
+ * @param [in,out]  q              the stream to write
+ * @param [in]      pts            packet presentation time stamp
+ * @param [in]      dts            packet decoding time stamp
+ * @param [in]      id             stream id
+ * @param [in]      start_code     PES packet start code
+ * @param [in]      header_len     PES header size
+ * @param [in]      packet_size    the total packet size
+ * @param [in]      payload_size   the payload size of the packet
+ * @param [in]      stuffing_size  the stuffing size of the packet
+ * @param [in]      trailer_size   the trailer size of the packet
+ * @return          bytes wirtten to PES stream.
+ */
+int pes_mux_write(AVFormatContext *ctx, int stream_index, uint8_t* q,
+    int64_t pts,int64_t dts, int  id, int startcode,
+    int header_len, int packet_size, int payload_size, int stuffing_size, int trailer_size)
+{
+    PESStream *stream = ctx->streams[stream_index]->priv_data;
+    PESContext *context = ctx->priv_data;
+    int pes_flags, i, nb_frames;
+    int data_size = payload_size - stuffing_size;
+
+    bytestream_put_be32(&q, startcode);
+    bytestream_put_be16(&q, packet_size);
+    bytestream_put_byte(&q, 0x80); /* mpeg2 id */
+
+    pes_flags=0;
+
+    if (pts != AV_NOPTS_VALUE) {
+        pes_flags |= 0x80;
+        if (dts != pts)
+            pes_flags |= 0x40;
+    }
+
+    /* Both the MPEG-2 and the SVCD standards demand that the
+       P-STD_buffer_size field be included in the first packet of
+       every stream. (see SVCD standard p. 26 V.2.3.1 and V.2.3.2
+       and MPEG-2 standard 2.7.7) */
+    if (context->packet_number == 0)
+        pes_flags |= 0x01;
+
+    bytestream_put_byte(&q, pes_flags);
+    bytestream_put_byte(&q, header_len - 3 + stuffing_size);
+
+    if (pes_flags & 0x80)  /*write pts*/
+        put_timestamp(q, (pes_flags & 0x40) ? 0x03 : 0x02, pts);
+    if (pes_flags & 0x40)  /*write dts*/
+        put_timestamp(q, 0x01, dts);
+
+    if (pes_flags & 0x01) {  /*write pes extension*/
+        bytestream_put_byte(&q, 0x10);
+
+        /* P-STD buffer info */
+        if (id == AUDIO_ID)
+            bytestream_put_be16(&q, 0x4000 | stream ->max_buffer_size/128);
+        else
+            bytestream_put_be16(&q, 0x6000 | stream ->max_buffer_size/1024);
+    }
+
+    /* special stuffing byte that is always written
+       to prevent accidental generation of start codes. */
+    //put_byte(&ctx->pb, 0xff);
+    bytestream_put_byte(&q, 0xff);
+
+    for (i=0;i<stuffing_size;i++)
+        bytestream_put_byte(&q, 0xff);
+
+    if (startcode == PRIVATE_STREAM_1) {
+        bytestream_put_byte(&q, id);
+        if (id >= 0xa0) {
+            /* LPCM (XXX: check nb_frames) */
+            bytestream_put_byte(&q, 7);
+            bytestream_put_be16(&q, 4); /* skip 3 header bytes */
+            bytestream_put_byte(&q, stream->lpcm_header[0]);
+            bytestream_put_byte(&q, stream->lpcm_header[1]);
+            bytestream_put_byte(&q, stream->lpcm_header[2]);
+        } else if (id >= 0x40) {
+            /* AC3 */
+            nb_frames= get_nb_frames(ctx, stream, data_size);
+            bytestream_put_byte(&q, nb_frames);
+            bytestream_put_be16(&q, trailer_size+1);
+        }
+    }
+
+    /* output data */
+    if (av_fifo_read(&stream->fifo, q, data_size) < 0)
+        return -1;
+    q += data_size;
+    return data_size;
+}
+
+/*
+ * Remove decoded packets of each stream.
+ * @param[in] ctx  the AVFormatContext
+ * @param[in] scr  System Clock Reference of PES stream.
+ * @return  NULL
+ */
+void pes_remove_decoded_packets(AVFormatContext *ctx, int64_t scr)
+{
+    int i;
+
+    for (i = 0; i < ctx->nb_streams; i++){
+        AVStream *st = ctx->streams[i];
+        PESStream *stream = st->priv_data;
+        PacketDesc *pkt_desc= stream->predecode_packet;
+
+        while (pkt_desc && scr > pkt_desc->dts){ //FIXME > vs >=
+            if (stream->buffer_index < pkt_desc->size ||
+                stream->predecode_packet == stream->premux_packet){
+                av_log(ctx, AV_LOG_ERROR, "buffer underflow\n");
+                break;
+            }
+            stream->buffer_index -= pkt_desc->size;
+            stream->predecode_packet= pkt_desc->next;
+            av_freep(&pkt_desc);
+        }
+    }
+}

Property changes on: libavformat/pes.c
___________________________________________________________________
Name: svn:executable
   + *

Index: libavformat/pes.h
===================================================================
--- libavformat/pes.h	(revision 0)
+++ libavformat/pes.h	(revision 0)
@@ -0,0 +1,136 @@
+/*
+ * copyright (c) 2007 Xiaohui Sun <sunxiaohui@dsp.ac.cn>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file pes.h
+ * PES packetizer api header.
+ */
+
+#ifndef PES_H
+#define PES_H
+
+#include "avformat.h"
+#include "fifo.h"
+
+typedef struct PacketDesc {
+    int64_t pts;
+    int64_t dts;
+    int size;
+    int unwritten_size;
+    int flags;
+    struct PacketDesc *next;
+} PacketDesc;
+
+typedef struct {
+    int packet_number;
+} PESContext;
+
+typedef struct {
+    uint8_t id;
+    AVFifoBuffer fifo;
+    int max_buffer_size; /* in bytes */
+    int buffer_index;
+    uint8_t lpcm_header[3];
+    int lpcm_align;
+    PacketDesc *predecode_packet;
+    PacketDesc *premux_packet;
+    PacketDesc **next_packet;
+} PESStream;
+
+
+#define AUDIO_ID 0xc0
+#define VIDEO_ID 0xe0
+#define AC3_ID   0x80
+#define DTS_ID   0x8a
+#define LPCM_ID  0xa0
+#define SUB_ID   0x20
+
+/* mpeg2 */
+#define PROGRAM_STREAM_MAP 0x1bc
+#define PRIVATE_STREAM_1   0x1bd
+#define PADDING_STREAM     0x1be
+#define PRIVATE_STREAM_2   0x1bf
+
+
+static const int lpcm_freq_tab[4] = { 48000, 96000, 44100, 32000 };
+
+
+/*
+ * Initialization of PES mux.
+ * @param[in] ctx the AVFormatContext which contains streams
+ * @return  On error a negative value is returned, on success zero.
+ */
+int pes_mux_init(AVFormatContext *ctx);
+
+/*
+ * Finalization of PES mux.
+ * @param [in] ctx the AVFormatContext which contains streams.
+ * @return  NULL
+ */
+void pes_mux_end(AVFormatContext *ctx);
+
+/*
+ * Write packet into PES fifo.
+ * @param [in] ctx  the AVFormatContext which contains streams.
+ * @param [in] pkt  the packet to write.
+ * @return  NULL
+ */
+void pes_write_packet(AVFormatContext *ctx, AVPacket *pkt);
+
+/*
+ * Find the most fit stream to be muxed.
+ * @param[in] ctx   the AVFormatContext
+ * @param[in] packet_size  the packet size of PES stream
+ * @param[in] flush   whether we flush after every single subtitle packet for subtitle
+ * @param[out] best_i       the best fit stream index
+ * @return  On error a negative or zero value is returned, on success 1 is returned
+ */
+int pes_find_beststream(AVFormatContext *ctx, int packet_size, int flush, int64_t scr, int* best_i);
+
+/*
+ * Mux streams into a PES packet.
+ * @param [in]      ctx            the AVFormatContext which contains streams
+ * @param [in]      stream_index   the stream index to write
+ * @param [in,out]  q              the stream to write
+ * @param [in]      pts            packet presentation time stamp
+ * @param [in]      dts            packet decoding time stamp
+ * @param [in]      id             stream id
+ * @param [in]      start_code     PES packet start code
+ * @param [in]      header_len     PES header size
+ * @param [in]      packet_size    the total packet size
+ * @param [in]      payload_size   the payload size of the packet
+ * @param [in]      stuffing_size  the stuffing size of the packet
+ * @param [in]      trailer_size   the trailer size of the packet
+ * @return   bytes wirtten to PES stream.
+ */
+int pes_mux_write(AVFormatContext *ctx, int stream_index, uint8_t* q,
+          int64_t pts,int64_t dts, int  id, int startcode,
+          int header_len, int packet_size, int payload_size, int stuffing_size, int tailer_size);
+
+/*
+ * Remove decoded packets of each stream.
+ * @param[in] ctx  the AVFormatContext
+ * @param[in] scr  System Clock Reference of PES stream.
+ * @return  NULL
+ */
+void pes_remove_decoded_packets(AVFormatContext *ctx, int64_t scr);
+
+
+#endif/* PES_H */

Property changes on: libavformat/pes.h
___________________________________________________________________
Name: svn:executable
   + *

Index: libavformat/Makefile
===================================================================
--- libavformat/Makefile	(revision 9394)
+++ libavformat/Makefile	(working copy)
@@ -84,11 +84,11 @@
 OBJS-$(CONFIG_MP3_MUXER)                 += mp3.o
 OBJS-$(CONFIG_MP4_MUXER)                 += movenc.o riff.o isom.o
 OBJS-$(CONFIG_MPC_DEMUXER)               += mpc.o
-OBJS-$(CONFIG_MPEG1SYSTEM_MUXER)         += mpegenc.o
-OBJS-$(CONFIG_MPEG1VCD_MUXER)            += mpegenc.o
-OBJS-$(CONFIG_MPEG2DVD_MUXER)            += mpegenc.o
-OBJS-$(CONFIG_MPEG2VOB_MUXER)            += mpegenc.o
-OBJS-$(CONFIG_MPEG2SVCD_MUXER)           += mpegenc.o
+OBJS-$(CONFIG_MPEG1SYSTEM_MUXER)         += mpegenc.o pes.o
+OBJS-$(CONFIG_MPEG1VCD_MUXER)            += mpegenc.o pes.o
+OBJS-$(CONFIG_MPEG2DVD_MUXER)            += mpegenc.o pes.o
+OBJS-$(CONFIG_MPEG2VOB_MUXER)            += mpegenc.o pes.o
+OBJS-$(CONFIG_MPEG2SVCD_MUXER)           += mpegenc.o pes.o
 OBJS-$(CONFIG_MPEG1VIDEO_MUXER)          += raw.o
 OBJS-$(CONFIG_MPEG2VIDEO_MUXER)          += raw.o
 OBJS-$(CONFIG_MPEGPS_DEMUXER)            += mpeg.o
Index: libavformat/mpeg.c
===================================================================
--- libavformat/mpeg.c	(revision 9394)
+++ libavformat/mpeg.c	(working copy)
@@ -21,6 +21,7 @@
 
 #include "avformat.h"
 #include "mpeg.h"
+#include "pes.h"
 
 //#define DEBUG_SEEK
 
Index: libavformat/mpeg.h
===================================================================
--- libavformat/mpeg.h	(revision 9394)
+++ libavformat/mpeg.h	(working copy)
@@ -29,19 +29,6 @@
 #define PACKET_START_CODE_PREFIX    ((unsigned int)0x00000100)
 #define ISO_11172_END_CODE          ((unsigned int)0x000001b9)
 
-/* mpeg2 */
-#define PROGRAM_STREAM_MAP 0x1bc
-#define PRIVATE_STREAM_1   0x1bd
-#define PADDING_STREAM     0x1be
-#define PRIVATE_STREAM_2   0x1bf
-
-#define AUDIO_ID 0xc0
-#define VIDEO_ID 0xe0
-#define AC3_ID   0x80
-#define DTS_ID   0x8a
-#define LPCM_ID  0xa0
-#define SUB_ID   0x20
-
 #define STREAM_TYPE_VIDEO_MPEG1     0x01
 #define STREAM_TYPE_VIDEO_MPEG2     0x02
 #define STREAM_TYPE_AUDIO_MPEG1     0x03
@@ -55,6 +42,5 @@
 #define STREAM_TYPE_AUDIO_AC3       0x81
 #define STREAM_TYPE_AUDIO_DTS       0x8a
 
-static const int lpcm_freq_tab[4] = { 48000, 96000, 44100, 32000 };
 
 #endif /* AVFORMAT_MPEG_H */
Index: libavformat/mpegenc.c
===================================================================
--- libavformat/mpegenc.c	(revision 9394)
+++ libavformat/mpegenc.c	(working copy)
@@ -24,6 +24,7 @@
 #include "bitstream.h"
 #include "fifo.h"
 #include "mpeg.h"
+#include "pes.h"
 
 #define MAX_PAYLOAD_SIZE 4096
 //#define DEBUG_SEEK
@@ -31,32 +32,17 @@
 #undef NDEBUG
 #include <assert.h>
 
-typedef struct PacketDesc {
-    int64_t pts;
-    int64_t dts;
-    int size;
-    int unwritten_size;
-    int flags;
-    struct PacketDesc *next;
-} PacketDesc;
 
 typedef struct {
-    AVFifoBuffer fifo;
-    uint8_t id;
-    int max_buffer_size; /* in bytes */
-    int buffer_index;
-    PacketDesc *predecode_packet;
-    PacketDesc *premux_packet;
-    PacketDesc **next_packet;
+    PESStream pes_stream;
     int packet_number;
-    uint8_t lpcm_header[3];
-    int lpcm_align;
     int bytes_to_iframe;
     int align_iframe;
     int64_t vobu_start_pts;
 } StreamInfo;
 
 typedef struct {
+    PESContext pes_context;
     int packet_size; /* required packet size */
     int packet_number;
     int pack_header_freq;     /* frequency (in packets^-1) at which we send pack headers */
@@ -177,7 +163,7 @@
         int P_STD_max_mpeg_PS1 = 0;
 
         for(i=0;i<ctx->nb_streams;i++) {
-            StreamInfo *stream = ctx->streams[i]->priv_data;
+            PESStream *stream = ctx->streams[i]->priv_data;
 
             id = stream->id;
             if (id == 0xbd && stream->max_buffer_size > P_STD_max_mpeg_PS1) {
@@ -219,7 +205,7 @@
         /* audio stream info */
         private_stream_coded = 0;
         for(i=0;i<ctx->nb_streams;i++) {
-            StreamInfo *stream = ctx->streams[i]->priv_data;
+            PESStream *stream = ctx->streams[i]->priv_data;
 
 
             /* For VCDs, only include the stream info for the stream
@@ -263,7 +249,7 @@
 static int get_system_header_size(AVFormatContext *ctx)
 {
     int buf_index, i, private_stream_coded;
-    StreamInfo *stream;
+    PESStream *stream;
     MpegMuxContext *s = ctx->priv_data;
 
     if (s->is_dvd)
@@ -286,9 +272,10 @@
 static int mpeg_mux_init(AVFormatContext *ctx)
 {
     MpegMuxContext *s = ctx->priv_data;
-    int bitrate, i, mpa_id, mpv_id, mps_id, ac3_id, dts_id, lpcm_id, j;
+    int bitrate, i;
     AVStream *st;
     StreamInfo *stream;
+    PESStream *pes_stream;
     int audio_bitrate;
     int video_bitrate;
 
@@ -308,12 +295,6 @@
 
     s->audio_bound = 0;
     s->video_bound = 0;
-    mpa_id = AUDIO_ID;
-    ac3_id = AC3_ID;
-    dts_id = DTS_ID;
-    mpv_id = VIDEO_ID;
-    mps_id = SUB_ID;
-    lpcm_id = LPCM_ID;
     for(i=0;i<ctx->nb_streams;i++) {
         st = ctx->streams[i];
         stream = av_mallocz(sizeof(StreamInfo));
@@ -325,67 +306,30 @@
 
         switch(st->codec->codec_type) {
         case CODEC_TYPE_AUDIO:
-            if (st->codec->codec_id == CODEC_ID_AC3) {
-                stream->id = ac3_id++;
-            } else if (st->codec->codec_id == CODEC_ID_DTS) {
-                stream->id = dts_id++;
-            } else if (st->codec->codec_id == CODEC_ID_PCM_S16BE) {
-                stream->id = lpcm_id++;
-                for(j = 0; j < 4; j++) {
-                    if (lpcm_freq_tab[j] == st->codec->sample_rate)
-                        break;
-                }
-                if (j == 4)
-                    goto fail;
-                if (st->codec->channels > 8)
-                    return -1;
-                stream->lpcm_header[0] = 0x0c;
-                stream->lpcm_header[1] = (st->codec->channels - 1) | (j << 4);
-                stream->lpcm_header[2] = 0x80;
-                stream->lpcm_align = st->codec->channels * 2;
-            } else {
-                stream->id = mpa_id++;
-            }
-
-            /* This value HAS to be used for VCD (see VCD standard, p. IV-7).
-               Right now it is also used for everything else.*/
-            stream->max_buffer_size = 4 * 1024;
             s->audio_bound++;
             break;
         case CODEC_TYPE_VIDEO:
-            stream->id = mpv_id++;
-            if (st->codec->rc_buffer_size)
-                stream->max_buffer_size = 6*1024 + st->codec->rc_buffer_size/8;
-            else
-                stream->max_buffer_size = 230*1024; //FIXME this is probably too small as default
-#if 0
-                /* see VCD standard, p. IV-7*/
-                stream->max_buffer_size = 46 * 1024;
-            else
-                /* This value HAS to be used for SVCD (see SVCD standard, p. 26 V.2.3.2).
-                   Right now it is also used for everything else.*/
-                stream->max_buffer_size = 230 * 1024;
-#endif
             s->video_bound++;
             break;
         case CODEC_TYPE_SUBTITLE:
-            stream->id = mps_id++;
-            stream->max_buffer_size = 16 * 1024;
             break;
         default:
             return -1;
         }
-        av_fifo_init(&stream->fifo, 16);
     }
+
+    if(pes_mux_init(ctx) != 0)
+        goto fail;
+
     bitrate = 0;
     audio_bitrate = 0;
     video_bitrate = 0;
     for(i=0;i<ctx->nb_streams;i++) {
         int codec_rate;
         st = ctx->streams[i];
-        stream = (StreamInfo*) st->priv_data;
+        pes_stream = (PESStream*) st->priv_data;
 
-        if(st->codec->rc_max_rate || stream->id==VIDEO_ID)
+        if(st->codec->rc_max_rate ||pes_stream->id==VIDEO_ID)
             codec_rate= st->codec->rc_max_rate;
         else
             codec_rate= st->codec->bit_rate;
@@ -395,9 +339,9 @@
 
         bitrate += codec_rate;
 
-        if (stream->id==AUDIO_ID)
+        if (pes_stream->id==AUDIO_ID)
             audio_bitrate += codec_rate;
-        else if (stream->id==VIDEO_ID)
+        else if (pes_stream->id==VIDEO_ID)
             video_bitrate += codec_rate;
     }
 
@@ -615,38 +559,31 @@
         put_byte(pb, 0xff);
 }
 
-static int get_nb_frames(AVFormatContext *ctx, StreamInfo *stream, int len){
-    int nb_frames=0;
-    PacketDesc *pkt_desc= stream->premux_packet;
 
-    while(len>0){
-        if(pkt_desc->size == pkt_desc->unwritten_size)
-            nb_frames++;
-        len -= pkt_desc->unwritten_size;
-        pkt_desc= pkt_desc->next;
-    }
 
-    return nb_frames;
-}
-
 /* flush the packet on stream stream_index */
 static int flush_packet(AVFormatContext *ctx, int stream_index,
                          int64_t pts, int64_t dts, int64_t scr, int trailer_size)
 {
     MpegMuxContext *s = ctx->priv_data;
+    PESContext* pes_context = &s->pes_context;
     StreamInfo *stream = ctx->streams[stream_index]->priv_data;
-    uint8_t *buf_ptr;
+    PESStream *pes_stream = &stream->pes_stream;
+    uint8_t *buf_ptr, *p;
     int size, payload_size, startcode, id, stuffing_size, i, header_len;
-    int packet_size;
+    int packet_size, es_size;
     uint8_t buffer[128];
     int zero_trail_bytes = 0;
     int pad_packet_bytes = 0;
-    int pes_flags;
     int general_pack = 0;  /*"general" pack without data specific to one stream?*/
-    int nb_frames;
+    uint8_t *pes_buffer  = av_malloc(ctx->packet_size);
 
-    id = stream->id;
+    if(!pes_buffer)
+        return -1;
 
+    p = pes_buffer;
+    id = pes_stream->id;
+
 #if 0
     printf("packet ID=%2x PTS=%0.3f\n",
            id, pts / 90000.0);
@@ -780,7 +717,7 @@
             startcode = 0x100 + id;
         }
 
-        stuffing_size = payload_size - av_fifo_size(&stream->fifo);
+        stuffing_size = payload_size - av_fifo_size(&pes_stream->fifo);
 
         // first byte does not fit -> reset pts/dts + stuffing
         if(payload_size <= trailer_size && pts != AV_NOPTS_VALUE){
@@ -821,55 +758,21 @@
             payload_size -= stuffing_size;
             stuffing_size = 0;
         }
+        if(s->is_mpeg2) {
+            pes_context->packet_number = s->packet_number;
+            i =  pes_mux_write(ctx, stream_index, p, pts, dts, id, startcode,
+                 header_len, packet_size, payload_size, stuffing_size, trailer_size);
+            put_buffer(&ctx->pb, pes_buffer, p - pes_buffer);
+        } else {
 
-        nb_frames= get_nb_frames(ctx, stream, payload_size - stuffing_size);
+            put_be32(&ctx->pb, startcode);
 
-        put_be32(&ctx->pb, startcode);
+            put_be16(&ctx->pb, packet_size);
 
-        put_be16(&ctx->pb, packet_size);
-
-        if (!s->is_mpeg2)
             for(i=0;i<stuffing_size;i++)
                 put_byte(&ctx->pb, 0xff);
 
-        if (s->is_mpeg2) {
-            put_byte(&ctx->pb, 0x80); /* mpeg2 id */
-
-            pes_flags=0;
-
             if (pts != AV_NOPTS_VALUE) {
-                pes_flags |= 0x80;
-                if (dts != pts)
-                    pes_flags |= 0x40;
-            }
-
-            /* Both the MPEG-2 and the SVCD standards demand that the
-               P-STD_buffer_size field be included in the first packet of
-               every stream. (see SVCD standard p. 26 V.2.3.1 and V.2.3.2
-               and MPEG-2 standard 2.7.7) */
-            if (stream->packet_number == 0)
-                pes_flags |= 0x01;
-
-            put_byte(&ctx->pb, pes_flags); /* flags */
-            put_byte(&ctx->pb, header_len - 3 + stuffing_size);
-
-            if (pes_flags & 0x80)  /*write pts*/
-                put_timestamp(&ctx->pb, (pes_flags & 0x40) ? 0x03 : 0x02, pts);
-            if (pes_flags & 0x40)  /*write dts*/
-                put_timestamp(&ctx->pb, 0x01, dts);
-
-            if (pes_flags & 0x01) {  /*write pes extension*/
-                put_byte(&ctx->pb, 0x10); /* flags */
-
-                /* P-STD buffer info */
-                if (id == AUDIO_ID)
-                    put_be16(&ctx->pb, 0x4000 | stream->max_buffer_size/128);
-                else
-                    put_be16(&ctx->pb, 0x6000 | stream->max_buffer_size/1024);
-            }
-
-        } else {
-            if (pts != AV_NOPTS_VALUE) {
                 if (dts != pts) {
                     put_timestamp(&ctx->pb, 0x03, pts);
                     put_timestamp(&ctx->pb, 0x01, dts);
@@ -879,38 +782,15 @@
             } else {
                 put_byte(&ctx->pb, 0x0f);
             }
-        }
 
-        if (s->is_mpeg2) {
-            /* special stuffing byte that is always written
-               to prevent accidental generation of start codes. */
-            put_byte(&ctx->pb, 0xff);
-
-            for(i=0;i<stuffing_size;i++)
-                put_byte(&ctx->pb, 0xff);
-        }
-
-        if (startcode == PRIVATE_STREAM_1) {
-            put_byte(&ctx->pb, id);
-            if (id >= 0xa0) {
-                /* LPCM (XXX: check nb_frames) */
-                put_byte(&ctx->pb, 7);
-                put_be16(&ctx->pb, 4); /* skip 3 header bytes */
-                put_byte(&ctx->pb, stream->lpcm_header[0]);
-                put_byte(&ctx->pb, stream->lpcm_header[1]);
-                put_byte(&ctx->pb, stream->lpcm_header[2]);
-            } else if (id >= 0x40) {
-                /* AC3 */
-                put_byte(&ctx->pb, nb_frames);
-                put_be16(&ctx->pb, trailer_size+1);
+            /* output data */
+            if(av_fifo_generic_read(&pes_stream->fifo, payload_size - stuffing_size, &put_buffer, &ctx->pb) < 0) {
+                av_free(pes_buffer);
+                return -1;
             }
         }
-
-        /* output data */
-        if(av_fifo_generic_read(&stream->fifo, payload_size - stuffing_size, &put_buffer, &ctx->pb) < 0)
-            return -1;
         stream->bytes_to_iframe -= payload_size - stuffing_size;
-    }else{
+    } else {
         payload_size=
         stuffing_size= 0;
     }
@@ -918,7 +798,7 @@
     if (pad_packet_bytes > 0)
         put_padding_packet(ctx,&ctx->pb, pad_packet_bytes);
 
-    for(i=0;i<zero_trail_bytes;i++)
+    for (i=0;i<zero_trail_bytes;i++)
         put_byte(&ctx->pb, 0x00);
 
     put_flush_packet(&ctx->pb);
@@ -931,6 +811,17 @@
     if (!general_pack)
         stream->packet_number++;
 
+    es_size = payload_size - stuffing_size;
+    pes_stream->buffer_index += payload_size - stuffing_size;
+    while(pes_stream->premux_packet && pes_stream->premux_packet->unwritten_size <= es_size){
+        es_size -= pes_stream->premux_packet->unwritten_size;
+        pes_stream->premux_packet= pes_stream->premux_packet->next;
+    }
+
+    if(es_size)
+        pes_stream->premux_packet->unwritten_size -= es_size;
+
+    av_free(pes_buffer);
     return payload_size - stuffing_size;
 }
 
@@ -981,105 +872,19 @@
 }
 #endif
 
-static int remove_decoded_packets(AVFormatContext *ctx, int64_t scr){
-//    MpegMuxContext *s = ctx->priv_data;
-    int i;
-
-    for(i=0; i<ctx->nb_streams; i++){
-        AVStream *st = ctx->streams[i];
-        StreamInfo *stream = st->priv_data;
-        PacketDesc *pkt_desc;
-
-        while((pkt_desc= stream->predecode_packet)
-              && scr > pkt_desc->dts){ //FIXME > vs >=
-            if(stream->buffer_index < pkt_desc->size ||
-               stream->predecode_packet == stream->premux_packet){
-                av_log(ctx, AV_LOG_ERROR,
-                       "buffer underflow i=%d bufi=%d size=%d\n",
-                       i, stream->buffer_index, pkt_desc->size);
-                break;
-            }
-            stream->buffer_index -= pkt_desc->size;
-
-            stream->predecode_packet= pkt_desc->next;
-            av_freep(&pkt_desc);
-        }
-    }
-
-    return 0;
-}
-
 static int output_packet(AVFormatContext *ctx, int flush){
     MpegMuxContext *s = ctx->priv_data;
     AVStream *st;
-    StreamInfo *stream;
-    int i, avail_space, es_size, trailer_size;
+    PESStream *stream;
+    int es_size, trailer_size;
     int best_i= -1;
-    int best_score= INT_MIN;
-    int ignore_constraints=0;
+    int result;
     int64_t scr= s->last_scr;
     PacketDesc *timestamp_packet;
-    const int64_t max_delay= av_rescale(ctx->max_delay, 90000, AV_TIME_BASE);
 
-retry:
-    for(i=0; i<ctx->nb_streams; i++){
-        AVStream *st = ctx->streams[i];
-        StreamInfo *stream = st->priv_data;
-        const int avail_data=  av_fifo_size(&stream->fifo);
-        const int space= stream->max_buffer_size - stream->buffer_index;
-        int rel_space= 1024*space / stream->max_buffer_size;
-        PacketDesc *next_pkt= stream->premux_packet;
+    if((result = pes_find_beststream(ctx, s->packet_size, flush, scr, &best_i)) <= 0)
+        return result;
 
-        /* for subtitle, a single PES packet must be generated,
-           so we flush after every single subtitle packet */
-        if(s->packet_size > avail_data && !flush
-           && st->codec->codec_type != CODEC_TYPE_SUBTITLE)
-            return 0;
-        if(avail_data==0)
-            continue;
-        assert(avail_data>0);
-
-        if(space < s->packet_size && !ignore_constraints)
-            continue;
-
-        if(next_pkt && next_pkt->dts - scr > max_delay)
-            continue;
-
-        if(rel_space > best_score){
-            best_score= rel_space;
-            best_i = i;
-            avail_space= space;
-        }
-    }
-
-    if(best_i < 0){
-        int64_t best_dts= INT64_MAX;
-
-        for(i=0; i<ctx->nb_streams; i++){
-            AVStream *st = ctx->streams[i];
-            StreamInfo *stream = st->priv_data;
-            PacketDesc *pkt_desc= stream->predecode_packet;
-            if(pkt_desc && pkt_desc->dts < best_dts)
-                best_dts= pkt_desc->dts;
-        }
-
-#if 0
-        av_log(ctx, AV_LOG_DEBUG, "bumping scr, scr:%f, dts:%f\n",
-               scr/90000.0, best_dts/90000.0);
-#endif
-        if(best_dts == INT64_MAX)
-            return 0;
-
-        if(scr >= best_dts+1 && !ignore_constraints){
-            av_log(ctx, AV_LOG_ERROR, "packet too large, ignoring buffer limits to mux it\n");
-            ignore_constraints= 1;
-        }
-        scr= FFMAX(best_dts+1, scr);
-        if(remove_decoded_packets(ctx, scr) < 0)
-            return -1;
-        goto retry;
-    }
-
     assert(best_i >= 0);
 
     st = ctx->streams[best_i];
@@ -1087,8 +892,6 @@
 
     assert(av_fifo_size(&stream->fifo) > 0);
 
-    assert(avail_space >= s->packet_size || ignore_constraints);
-
     timestamp_packet= stream->premux_packet;
     if(timestamp_packet->unwritten_size == timestamp_packet->size){
         trailer_size= 0;
@@ -1116,19 +919,10 @@
         }
     }
 
-    stream->buffer_index += es_size;
     s->last_scr += s->packet_size*90000LL / (s->mux_rate*50LL); //FIXME rounding and first few bytes of each packet
 
-    while(stream->premux_packet && stream->premux_packet->unwritten_size <= es_size){
-        es_size -= stream->premux_packet->unwritten_size;
-        stream->premux_packet= stream->premux_packet->next;
-    }
-    if(es_size)
-        stream->premux_packet->unwritten_size -= es_size;
+    pes_remove_decoded_packets(ctx, s->last_scr);
 
-    if(remove_decoded_packets(ctx, s->last_scr) < 0)
-        return -1;
-
     return 1;
 }
 
@@ -1136,39 +930,18 @@
 {
     MpegMuxContext *s = ctx->priv_data;
     int stream_index= pkt->stream_index;
-    int size= pkt->size;
-    uint8_t *buf= pkt->data;
     AVStream *st = ctx->streams[stream_index];
     StreamInfo *stream = st->priv_data;
-    int64_t pts, dts;
-    PacketDesc *pkt_desc;
-    const int preload= av_rescale(ctx->preload, 90000, AV_TIME_BASE);
+    PESStream* pes_stream = &stream->pes_stream;
+    int64_t pts;
     const int is_iframe = st->codec->codec_type == CODEC_TYPE_VIDEO && (pkt->flags & PKT_FLAG_KEY);
 
-    pts= pkt->pts;
-    dts= pkt->dts;
+    pes_write_packet(ctx, pkt);
+    pts= pes_stream->predecode_packet->pts;
 
-    if(pts != AV_NOPTS_VALUE) pts += preload;
-    if(dts != AV_NOPTS_VALUE) dts += preload;
-
-//av_log(ctx, AV_LOG_DEBUG, "dts:%f pts:%f flags:%d stream:%d nopts:%d\n", dts/90000.0, pts/90000.0, pkt->flags, pkt->stream_index, pts != AV_NOPTS_VALUE);
-    if (!stream->premux_packet)
-        stream->next_packet = &stream->premux_packet;
-    *stream->next_packet=
-    pkt_desc= av_mallocz(sizeof(PacketDesc));
-    pkt_desc->pts= pts;
-    pkt_desc->dts= dts;
-    pkt_desc->unwritten_size=
-    pkt_desc->size= size;
-    if(!stream->predecode_packet)
-        stream->predecode_packet= pkt_desc;
-    stream->next_packet= &pkt_desc->next;
-
-    av_fifo_realloc(&stream->fifo, av_fifo_size(&stream->fifo) + size + 1);
-
     if (s->is_dvd){
         if (is_iframe && (s->packet_number == 0 || (pts - stream->vobu_start_pts >= 36000))) { // min VOBU length 0.4 seconds (mpucoder)
-            stream->bytes_to_iframe = av_fifo_size(&stream->fifo);
+            stream->bytes_to_iframe = av_fifo_size(&pes_stream->fifo);
             stream->align_iframe = 1;
             stream->vobu_start_pts = pts;
         } else {
@@ -1176,7 +949,6 @@
         }
     }
 
-    av_fifo_write(&stream->fifo, buf, size);
 
     for(;;){
         int ret= output_packet(ctx, 0);
@@ -1187,10 +959,6 @@
 
 static int mpeg_mux_end(AVFormatContext *ctx)
 {
-//    MpegMuxContext *s = ctx->priv_data;
-    StreamInfo *stream;
-    int i;
-
     for(;;){
         int ret= output_packet(ctx, 1);
         if(ret<0)
@@ -1199,18 +967,13 @@
             break;
     }
 
+    pes_mux_end(ctx);
     /* End header according to MPEG1 systems standard. We do not write
        it as it is usually not needed by decoders and because it
        complicates MPEG stream concatenation. */
     //put_be32(&ctx->pb, ISO_11172_END_CODE);
     //put_flush_packet(&ctx->pb);
 
-    for(i=0;i<ctx->nb_streams;i++) {
-        stream = ctx->streams[i]->priv_data;
-
-        assert(av_fifo_size(&stream->fifo) == 0);
-        av_fifo_free(&stream->fifo);
-    }
     return 0;
 }
 
