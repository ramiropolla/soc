Index: libavcodec/Makefile
===================================================================
--- libavcodec/Makefile	(revision 19613)
+++ libavcodec/Makefile	(working copy)
@@ -42,6 +42,7 @@
 OBJS-$(CONFIG_AC3_ENCODER)             += ac3enc.o ac3tab.o ac3.o
 OBJS-$(CONFIG_ALAC_DECODER)            += alac.o
 OBJS-$(CONFIG_ALAC_ENCODER)            += alacenc.o lpc.o
+OBJS-$(CONFIG_AMRNB_DECODER)           += amrnbdec.o celp_filters.o celp_math.o acelp_filters.o acelp_vectors.o lsp.o
 OBJS-$(CONFIG_AMV_DECODER)             += sp5xdec.o mjpegdec.o mjpeg.o
 OBJS-$(CONFIG_APE_DECODER)             += apedec.o
 OBJS-$(CONFIG_ASV1_DECODER)            += asv1.o mpeg12data.o
Index: libavcodec/allcodecs.c
===================================================================
--- libavcodec/allcodecs.c	(revision 19613)
+++ libavcodec/allcodecs.c	(working copy)
@@ -198,6 +198,7 @@
     REGISTER_ENCDEC  (AAC, aac);
     REGISTER_ENCDEC  (AC3, ac3);
     REGISTER_ENCDEC  (ALAC, alac);
+    REGISTER_DECODER (AMRNB, amrnb);
     REGISTER_DECODER (APE, ape);
     REGISTER_DECODER (ATRAC3, atrac3);
     REGISTER_DECODER (COOK, cook);
Index: doc/general.texi
===================================================================
--- doc/general.texi	(revision 19613)
+++ doc/general.texi	(working copy)
@@ -522,8 +522,8 @@
 @item ADPCM Westwood Studios IMA @tab     @tab  X
     @tab Used in Westwood Studios games like Command and Conquer.
 @item ADPCM Yamaha           @tab  X  @tab  X
-@item AMR-NB                 @tab  E  @tab  E
-    @tab supported through external library libopencore-amrnb
+@item AMR-NB                 @tab  X  @tab  E
+    @tab encoding supported through external library libopencore-amrnb
 @item AMR-WB                 @tab     @tab  E
     @tab decoding supported through external library libopencore-amrwb
 @item Apple lossless audio   @tab  X  @tab  X
Index: Changelog
===================================================================
--- Changelog	(revision 19613)
+++ Changelog	(working copy)
@@ -31,6 +31,7 @@
 - RTP depacketization of ASF and RTSP from WMS servers
 - RTMP support in libavformat
 - noX handling for OPT_BOOL X options
+- AMR-NB decoder
 
 
 
Index: libavcodec/celp_filters.c
===================================================================
--- libavcodec/celp_filters.c	(revision 19613)
+++ libavcodec/celp_filters.c	(working copy)
@@ -47,6 +47,16 @@
     }
 }
 
+void ff_celp_circ_addf(float *out, const float *in,
+                       const float *lagged, int lag, float fac, int n)
+{
+    int k;
+    for (k = 0; k < lag; k++)
+        out[k] = in[k] + fac * lagged[n + k - lag];
+    for (; k < n; k++)
+        out[k] = in[k] + fac * lagged[    k - lag];
+}
+
 int ff_celp_lp_synthesis_filter(int16_t *out,
                                 const int16_t* filter_coeffs,
                                 const int16_t* in,
Index: libavcodec/celp_filters.h
===================================================================
--- libavcodec/celp_filters.h	(revision 19613)
+++ libavcodec/celp_filters.h	(working copy)
@@ -42,6 +42,21 @@
                            int len);
 
 /**
+ * Add an array to a rotated array.
+ *
+ * out[k] = in[k] + fac * lagged[k-lag] with wrap-around
+ *
+ * @param out result vector
+ * @param in samples to be added unfiltered
+ * @param lagged samples to be rotated, multiplied and added
+ * @param lag delay from 0 to n
+ * @param fac coefficient to applied to lagged samples
+ * @param n number of samples
+ */
+void ff_celp_circ_addf(float *out, const float *in,
+                       const float *lagged, int lag, float fac, int n);
+
+/**
  * LP synthesis filter.
  * @param out [out] pointer to output buffer
  * @param filter_coeffs filter coefficients (-0x8000 <= (3.12) < 0x8000)
Index: libavcodec/acelp_filters.c
===================================================================
--- libavcodec/acelp_filters.c	(revision 19613)
+++ libavcodec/acelp_filters.c	(working copy)
@@ -93,3 +93,17 @@
         hpf_f[0] = tmp;
     }
 }
+
+void ff_acelp_high_pass_filterf(float *buf, float *mem, int length)
+{
+    int i;
+    float tmp;
+
+    for (i = 0; i < length; i++) {
+         tmp = buf[i] + 1.933105469 * mem[0] - 0.935913085 * mem[1];
+         buf[i] = 0.939819335 * (tmp - 2 * mem[0] + mem[1]);
+
+         mem[1] = mem[0];
+         mem[0] = tmp;
+    }
+}
Index: libavcodec/acelp_filters.h
===================================================================
--- libavcodec/acelp_filters.h	(revision 19613)
+++ libavcodec/acelp_filters.h	(working copy)
@@ -81,4 +81,12 @@
 void ff_acelp_high_pass_filter(int16_t* out, int hpf_f[2],
                                const int16_t* in, int length);
 
+/**
+ * high-pass filtering (6.2.2 of 3GPP TS 26.090)
+ * @param samples [in/out]Â·
+ * @param mem intermediate values used by filter (should be 0 initially)
+ * @param length input data size
+ */
+void ff_acelp_high_pass_filterf(float *samples, float mem[2], int length);
+
 #endif /* AVCODEC_ACELP_FILTERS_H */
Index: libavcodec/acelp_vectors.c
===================================================================
--- libavcodec/acelp_vectors.c	(revision 19613)
+++ libavcodec/acelp_vectors.c	(working copy)
@@ -22,6 +22,7 @@
 
 #include <inttypes.h>
 #include "avcodec.h"
+#include "celp_math.h"
 #include "acelp_vectors.h"
 
 const uint8_t ff_fc_2pulses_9bits_track1[16] =
@@ -155,3 +156,13 @@
         out[i] = weight_coeff_a * in_a[i]
                + weight_coeff_b * in_b[i];
 }
+
+void ff_scale_to(float *out, const float *in, float norm_squared, const int n)
+{
+    int i;
+    float scalefactor = ff_dot_productf(in, in, n);
+    if (scalefactor)
+        scalefactor = sqrt(norm_squared / scalefactor);
+    for (i = 0; i < n; i++)
+        out[i] = in[i] * scalefactor;
+}
Index: libavcodec/acelp_vectors.h
===================================================================
--- libavcodec/acelp_vectors.h	(revision 19613)
+++ libavcodec/acelp_vectors.h	(working copy)
@@ -164,4 +164,21 @@
 void ff_weighted_vector_sumf(float *out, const float *in_a, const float *in_b,
                              float weight_coeff_a, float weight_coeff_b, int length);
 
+/**
+ * Set the sum of squares of a signal by scaling
+ *
+ * @param out output samples
+ * @param in input samples
+ * @param norm_squared new sum of squares
+ * @param n number of samples
+ *
+ * @note If the input is zero (or its energy underflows), the output is zero.
+ *       This is the behavior of AGC in the AMR reference decoder. The QCELP
+ *       reference decoder seems to have undefined behavior.
+ *
+ * TIA/EIA/IS-733 2.4.8.3-2/3/4/5, 2.4.8.6
+ * 3GPP TS 26.090 6.1 (6)
+ */
+void ff_scale_to(float *out, const float *in, float norm_squared, const int n);
+
 #endif /* AVCODEC_ACELP_VECTORS_H */
Index: libavcodec/qcelpdec.c
===================================================================
--- libavcodec/qcelpdec.c	(revision 19613)
+++ libavcodec/qcelpdec.c	(working copy)
@@ -406,31 +406,6 @@
 }
 
 /**
- * Compute the gain control
- *
- * @param v_in gain-controlled vector
- * @param v_ref vector to control gain of
- *
- * @return gain control
- *
- * FIXME: If v_ref is a zero vector, it energy is zero
- *        and the behavior of the gain control is
- *        undefined in the specs.
- *
- * TIA/EIA/IS-733 2.4.8.3-2/3/4/5, 2.4.8.6
- */
-static float compute_gain_ctrl(const float *v_ref, const float *v_in, const int len)
-{
-    float scalefactor = ff_dot_productf(v_in, v_in, len);
-
-    if(scalefactor)
-        scalefactor = sqrt(ff_dot_productf(v_ref, v_ref, len) / scalefactor);
-    else
-        av_log_missing_feature(NULL, "Zero energy for gain control", 1);
-    return scalefactor;
-}
-
-/**
  * Apply generic gain control.
  *
  * @param v_out output vector
@@ -442,15 +417,11 @@
 static void apply_gain_ctrl(float *v_out, const float *v_ref,
                             const float *v_in)
 {
-    int   i, j, len;
-    float scalefactor;
+    int i;
 
-    for(i=0, j=0; i<4; i++)
-    {
-        scalefactor = compute_gain_ctrl(v_ref + j, v_in + j, 40);
-        for(len=j+40; j<len; j++)
-            v_out[j] = scalefactor * v_in[j];
-    }
+    for(i = 0; i < 160; i += 40)
+        ff_scale_to(v_out + i, v_in + i,
+                    ff_dot_productf(v_ref + i, v_ref + i, 40), 40);
 }
 
 /**
