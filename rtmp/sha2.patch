Index: libavutil/Makefile
===================================================================
--- libavutil/Makefile
+++ libavutil/Makefile
@@ -17,7 +17,7 @@
           mem.h                                                         \
           pixfmt.h                                                      \
           rational.h                                                    \
-          sha1.h                                                        \
+          sha.h                                                         \
 
 OBJS = adler32.o                                                        \
        aes.o                                                            \
@@ -37,11 +37,11 @@
        random_seed.o                                                    \
        rational.o                                                       \
        rc4.o                                                            \
-       sha1.o                                                           \
+       sha.o                                                            \
        tree.o                                                           \
        utils.o                                                          \
 
-TESTPROGS = adler32 aes base64 crc des lls md5 pca sha1 softfloat tree
+TESTPROGS = adler32 aes base64 crc des lls md5 pca sha softfloat tree
 TESTPROGS-$(HAVE_LZO1X_999_COMPRESS) += lzo
 
 DIRS = arm bfin sh4 x86
Index: libavutil/avutil.h
===================================================================
--- libavutil/avutil.h
+++ libavutil/avutil.h
@@ -35,7 +35,7 @@
 #define AV_VERSION(a, b, c) AV_VERSION_DOT(a, b, c)
 
 #define LIBAVUTIL_VERSION_MAJOR 50
-#define LIBAVUTIL_VERSION_MINOR  3
+#define LIBAVUTIL_VERSION_MINOR  4
 #define LIBAVUTIL_VERSION_MICRO  0
 
 #define LIBAVUTIL_VERSION_INT   AV_VERSION_INT(LIBAVUTIL_VERSION_MAJOR, \
Index: libavutil/sha.c
===================================================================
--- libavutil/sha.c
+++ libavutil/sha.c
@@ -1,6 +1,8 @@
 /*
  * Copyright (C) 2007 Michael Niedermayer <michaelni@gmx.at>
+ * Copyright (C) 2009 Konstantin Shishkov
  * based on public domain SHA-1 code by Steve Reid <steve@edmweb.com>
+ * and on BSD-licensed SHA-2 code by Aaron D. Gifford
  *
  * This file is part of FFmpeg.
  *
@@ -21,15 +23,19 @@
 
 #include "common.h"
 #include "bswap.h"
-#include "sha1.h"
+#include "sha.h"
 
-typedef struct AVSHA1 {
-    uint64_t count;
-    uint8_t buffer[64];
-    uint32_t state[5];
-} AVSHA1;
+/** hash context */
+typedef struct AVSHA {
+    uint8_t  digest_len;  ///< digest length in 32-bit words
+    uint32_t state[8];    ///< current hash value
+    uint8_t  buffer[64];  ///< 512-bit buffer of input values used in hash updating 
+    uint64_t count;       ///< number of bytes in buffer
+    /** function used to update hash for 512-bit input block */
+    void     (*transform)(uint32_t *state, const uint8_t buffer[64]);
+} AVSHA;
 
-const int av_sha1_size = sizeof(AVSHA1);
+const int av_sha_size = sizeof(AVSHA);
 
 #define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))
 
@@ -43,9 +49,8 @@
 #define R3(v,w,x,y,z,i) z += (((w|x)&y)|(w&x)) + blk (i) + 0x8F1BBCDC + rol(v, 5); w = rol(w, 30);
 #define R4(v,w,x,y,z,i) z += ( w^x     ^y)     + blk (i) + 0xCA62C1D6 + rol(v, 5); w = rol(w, 30);
 
-/* Hash a single 512-bit block. This is the core of the algorithm. */
 
-static void transform(uint32_t state[5], const uint8_t buffer[64])
+static void sha1_transform(uint32_t *state, const uint8_t buffer[64])
 {
     uint32_t block[80];
     unsigned int i, a, b, c, d, e;
@@ -123,18 +128,163 @@
     state[4] += e;
 }
 
-void av_sha1_init(AVSHA1* ctx)
+static const uint32_t K256[64] = {
+    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
+    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
+    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
+    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
+    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
+    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
+    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
+    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
+    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
+    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
+    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
+    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
+    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
+    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
+    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
+    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
+};
+
+
+#define ROR32(b,x)  (((x) >> (b)) | ((x) << (32 - (b))))
+#define Ch(x,y,z)   (((x) & (y)) ^ ((~(x)) & (z)))
+#define Maj(x,y,z)  (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))
+
+#define Sigma0_256(x)   (ROR32(2,  (x)) ^ ROR32(13, (x)) ^ ROR32(22, (x)))
+#define Sigma1_256(x)   (ROR32(6,  (x)) ^ ROR32(11, (x)) ^ ROR32(25, (x)))
+#define sigma0_256(x)   (ROR32(7,  (x)) ^ ROR32(18, (x)) ^ ((x) >> 3))
+#define sigma1_256(x)   (ROR32(17, (x)) ^ ROR32(19, (x)) ^ ((x) >> 10))
+
+#undef blk
+#define blk(i)  (block[i] = block[i - 16] + sigma0_256(block[i - 15]) + \
+                            sigma1_256(block[i - 2]) + block[i - 7])
+
+#define ROUND256(a,b,c,d,e,f,g,h)   \
+    T1 += (h) + Sigma1_256(e) + Ch((e), (f), (g)) + K256[i]; \
+    (d) += T1; \
+    (h) = T1 + Sigma0_256(a) + Maj((a), (b), (c)); \
+    i++
+
+#define ROUND256_0_TO_15(a,b,c,d,e,f,g,h)   \
+    T1 = blk0(i); \
+    ROUND256(a,b,c,d,e,f,g,h)
+
+#define ROUND256_16_TO_63(a,b,c,d,e,f,g,h)   \
+    T1 = blk(i); \
+    ROUND256(a,b,c,d,e,f,g,h)
+
+static void sha256_transform(uint32_t *state, const uint8_t buffer[64])
 {
-    ctx->state[0] = 0x67452301;
-    ctx->state[1] = 0xEFCDAB89;
-    ctx->state[2] = 0x98BADCFE;
-    ctx->state[3] = 0x10325476;
-    ctx->state[4] = 0xC3D2E1F0;
-    ctx->count    = 0;
+    unsigned int i, a, b, c, d, e, f, g, h;
+    uint32_t block[64];
+    uint32_t T1, T2;
+
+    a = state[0];
+    b = state[1];
+    c = state[2];
+    d = state[3];
+    e = state[4];
+    f = state[5];
+    g = state[6];
+    h = state[7];
+#if CONFIG_SMALL
+    for (i = 0; i < 64; i++) {
+        if (i < 16)
+            T1 = blk0(i);
+        else
+            T1 = blk(i);
+        T1 += h + Sigma1_256(e) + Ch(e, f, g) + K256[i];
+        T2 = Sigma0_256(a) + Maj(a, b, c);
+        h = g;
+        g = f;
+        f = e;
+        e = d + T1;
+        d = c;
+        c = b;
+        b = a;
+        a = T1 + T2;
+    }
+#else
+    for (i = 0; i < 16;) {
+        ROUND256_0_TO_15(a, b, c, d, e, f, g, h);
+        ROUND256_0_TO_15(h, a, b, c, d, e, f, g);
+        ROUND256_0_TO_15(g, h, a, b, c, d, e, f);
+        ROUND256_0_TO_15(f, g, h, a, b, c, d, e);
+        ROUND256_0_TO_15(e, f, g, h, a, b, c, d);
+        ROUND256_0_TO_15(d, e, f, g, h, a, b, c);
+        ROUND256_0_TO_15(c, d, e, f, g, h, a, b);
+        ROUND256_0_TO_15(b, c, d, e, f, g, h, a);
+    }
+
+    for (; i < 64;) {
+        ROUND256_16_TO_63(a, b, c, d, e, f, g, h);
+        ROUND256_16_TO_63(h, a, b, c, d, e, f, g);
+        ROUND256_16_TO_63(g, h, a, b, c, d, e, f);
+        ROUND256_16_TO_63(f, g, h, a, b, c, d, e);
+        ROUND256_16_TO_63(e, f, g, h, a, b, c, d);
+        ROUND256_16_TO_63(d, e, f, g, h, a, b, c);
+        ROUND256_16_TO_63(c, d, e, f, g, h, a, b);
+        ROUND256_16_TO_63(b, c, d, e, f, g, h, a);
+    }
+#endif
+    state[0] += a;
+    state[1] += b;
+    state[2] += c;
+    state[3] += d;
+    state[4] += e;
+    state[5] += f;
+    state[6] += g;
+    state[7] += h;
 }
 
-void av_sha1_update(AVSHA1* ctx, const uint8_t* data, unsigned int len)
+
+int av_sha_init(AVSHA* ctx, int bits)
 {
+    if (bits & 0x1F)
+        return -1;
+    ctx->digest_len = bits >> 5;
+    switch (ctx->digest_len) {
+    case 5: // SHA-1
+        ctx->state[0] = 0x67452301;
+        ctx->state[1] = 0xEFCDAB89;
+        ctx->state[2] = 0x98BADCFE;
+        ctx->state[3] = 0x10325476;
+        ctx->state[4] = 0xC3D2E1F0;
+        ctx->transform = sha1_transform;
+        break;
+    case 7: // SHA-224
+        ctx->state[0] = 0xC1059ED8;
+        ctx->state[1] = 0x367CD507;
+        ctx->state[2] = 0x3070DD17;
+        ctx->state[3] = 0xF70E5939;
+        ctx->state[4] = 0xFFC00B31;
+        ctx->state[5] = 0x68581511;
+        ctx->state[6] = 0x64F98FA7;
+        ctx->state[7] = 0xBEFA4FA4;
+        ctx->transform = sha256_transform;
+        break;
+    case 8: // SHA-256
+        ctx->state[0] = 0x6A09E667;
+        ctx->state[1] = 0xBB67AE85;
+        ctx->state[2] = 0x3C6EF372;
+        ctx->state[3] = 0xA54FF53A;
+        ctx->state[4] = 0x510E527F;
+        ctx->state[5] = 0x9B05688C;
+        ctx->state[6] = 0x1F83D9AB;
+        ctx->state[7] = 0x5BE0CD19;
+        ctx->transform = sha256_transform;
+        break;
+    default:
+        return -1;
+    }
+    ctx->count = 0;
+    return 0;
+}
+
+void av_sha_update(AVSHA* ctx, const uint8_t* data, unsigned int len)
+{
     unsigned int i, j;
 
     j = ctx->count & 63;
@@ -143,16 +293,16 @@
     for (i = 0; i < len; i++) {
         ctx->buffer[j++] = data[i];
         if (64 == j) {
-            transform(ctx->state, ctx->buffer);
+            ctx->transform(ctx->state, ctx->buffer);
             j = 0;
         }
     }
 #else
     if ((j + len) > 63) {
-        memcpy(&ctx->buffer[j], data, (i = 64 - j));
-        transform(ctx->state, ctx->buffer);
+        memcpy(&ctx->buffer[j], data, (i = 64-j));
+        ctx->transform(ctx->state, ctx->buffer);
         for (; i + 63 < len; i += 64)
-            transform(ctx->state, &data[i]);
+            ctx->transform(ctx->state, &data[i]);
         j = 0;
     } else
         i = 0;
@@ -160,16 +310,16 @@
 #endif
 }
 
-void av_sha1_final(AVSHA1* ctx, uint8_t digest[20])
+void av_sha_final(AVSHA* ctx, uint8_t *digest)
 {
     int i;
     uint64_t finalcount = be2me_64(ctx->count << 3);
 
-    av_sha1_update(ctx, "\200", 1);
+    av_sha_update(ctx, "\200", 1);
     while ((ctx->count & 63) != 56)
-        av_sha1_update(ctx, "", 1);
-    av_sha1_update(ctx, (uint8_t *)&finalcount, 8); /* Should cause a transform() */
-    for (i = 0; i < 5; i++)
+        av_sha_update(ctx, "", 1);
+    av_sha_update(ctx, (uint8_t *)&finalcount, 8); /* Should cause a transform() */
+    for (i = 0; i < ctx->digest_len; i++)
         ((uint32_t*)digest)[i] = be2me_32(ctx->state[i]);
 }
 
@@ -179,29 +329,48 @@
 
 int main(void)
 {
-    int i, k;
-    AVSHA1 ctx;
-    unsigned char digest[20];
+    int i, j, k;
+    AVSHA ctx;
+    unsigned char digest[32];
+    const int lengths[3] = { 160, 224, 256 };
 
+    for (j = 0; j < 3; j++) {
+        printf("Testing SHA-%d\n", lengths[j]);
     for (k = 0; k < 3; k++) {
-        av_sha1_init(&ctx);
+        av_sha_init(&ctx, lengths[j]);
         if (k == 0)
-            av_sha1_update(&ctx, "abc", 3);
+            av_sha_update(&ctx, "abc", 3);
         else if (k == 1)
-            av_sha1_update(&ctx, "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq", 56);
+            av_sha_update(&ctx, "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq", 56);
         else
-            for (i = 0; i < 1000 * 1000; i++)
-                av_sha1_update(&ctx, "a", 1);
-        av_sha1_final(&ctx, digest);
-        for (i = 0; i < 20; i++)
+            for (i = 0; i < 1000*1000; i++)
+                av_sha_update(&ctx, "a", 1);
+        av_sha_final(&ctx, digest);
+        for (i = 0; i < lengths[j] >> 3; i++)
             printf("%02X", digest[i]);
         putchar('\n');
     }
+    switch (j) {
+    case 0:
     //test vectors (from FIPS PUB 180-1)
     printf("A9993E36 4706816A BA3E2571 7850C26C 9CD0D89D\n"
            "84983E44 1C3BD26E BAAE4AA1 F95129E5 E54670F1\n"
            "34AA973C D4C4DAA4 F61EEB2B DBAD2731 6534016F\n");
-
+        break;
+    case 1:
+        //test vectors (from FIPS PUB 180-2 Appendix A)
+        printf("23097d22 3405d822 8642a477 bda255b3 2aadbce4 bda0b3f7 e36c9da7\n"
+               "75388b16 512776cc 5dba5da1 fd890150 b0c6455c b4f58b19 52522525\n"
+               "20794655 980c91d8 bbb4c1ea 97618a4b f03f4258 1948b2ee 4ee7ad67\n");
+        break;
+    case 2:
+        //test vectors (from FIPS PUB 180-2)
+        printf("ba7816bf 8f01cfea 414140de 5dae2223 b00361a3 96177a9c b410ff61 f20015ad\n"
+               "248d6a61 d20638b8 e5c02693 0c3e6039 a33ce459 64ff2167 f6ecedd4 19db06c1\n"
+               "cdc76e5c 9914fb92 81a1c7e2 84d73e67 f1809a48 a497200e 046d39cc c7112cd0\n");
+        break;
+    }
+    }
     return 0;
 }
 #endif
Index: libavutil/sha.h
===================================================================
--- libavutil/sha.h
+++ libavutil/sha.h
@@ -18,17 +18,39 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVUTIL_SHA1_H
-#define AVUTIL_SHA1_H
+#ifndef AVUTIL_SHA_H
+#define AVUTIL_SHA_H
 
 #include <stdint.h>
 
-extern const int av_sha1_size;
+extern const int av_sha_size;
 
-struct AVSHA1;
+struct AVSHA;
 
-void av_sha1_init(struct AVSHA1* context);
-void av_sha1_update(struct AVSHA1* context, const uint8_t* data, unsigned int len);
-void av_sha1_final(struct AVSHA1* context, uint8_t digest[20]);
+/**
+ * Initializes SHA-224/256 hashing.
+ *
+ * @param context pointer to the function context (of size av_sha_size)
+ * @param bits    number of bits in digest (SHA-1 - 160 bits, SHA-2 224 or 256 bits)
+ * @return        zero if initialization succeeded, -1 otherwise
+ */
+int av_sha_init(struct AVSHA* context, int bits);
 
-#endif /* AVUTIL_SHA1_H */
+/**
+ * Updates hash value.
+ *
+ * @param context hash function context
+ * @param data    input data to update hash with
+ * @param len     input data length
+ */
+void av_sha_update(struct AVSHA* context, const uint8_t* data, unsigned int len);
+
+/**
+ * Finishes hashing and output digest value.
+ *
+ * @param context hash function context
+ * @param digest  buffer where output digest value is storen
+ */
+void av_sha_final(struct AVSHA* context, uint8_t *digest);
+
+#endif /* AVUTIL_SHA_H */
